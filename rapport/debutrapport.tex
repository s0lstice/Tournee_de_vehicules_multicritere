\documentclass[twoside]{EPURapport}
\input{include.tex}

\thedocument{Rapport Projet Algorithme-C}{Tournée d'un véhicule multicritéres}%{Titre court}

\grade{Département Informatique\\ 3\ieme{} année\\ 2010 - 2011}

\authors{%
	\category{Étudiants}{%
		\name{Cyrille PICARD} \mail{cyrille.picard@etu.univ-tours.fr}
		\name{Michael PURET} \mail{michael.puret@etu.univ-tours.fr}
	}
	\details{DI3 2010 - 2011}
}

\supervisors{%
	\category{Encadrant}{%
		\name{Emmanuel Neron} \mail{emmanuel.neron@univ-tours.fr}
	}
	\details{Université François-Rabelais, Tours}
}

\abstracts{Description en français}
{Mots clés français}
{Description en anglais}
{Mots clés en anglais}


\begin{document}


\chapter{Introduction}

Pour ce projet nous intéressons à réaliser un programme qui permet en fonction d'une liste de lieux de ressortir la liste des différents parcours possible pour réaliser cette tournée entre les différents lieux. Ce problème est un peu similaire à celui du voyageur de commerce. 
Le principe de l'application qu'on essaye de développer est de permettre à partir d'une Base de données représentant la configuration d'une ville.
C'est à dire un ensemble de lieux relié entre par des arcs, de calculer un parcours pour passer par tout les lieux en fonction de leur intérêt pour l'utilisateur.
La difficulté majeur est de retourner des solutions dans une  période très courte. 

\begin{figure}[h]
\begin{center}
\includegraphics{graph.jpg}
\caption{Représentation simplifiée de la configuration}
\label{fig:Représentation simplifiée de la configuration}
\end{center}
\end{figure}

\part{Spécification}
\chapter{Cahier des charges}

Suite à la première rencontre avec notre encadrant un premier cahier des charges a été évoquer. Le logiciel doit retourner la liste des différents parcours possible pour visiter une série de lieux dans l'ordre désiré par l'utilisateur. Le but est de calculer un parcours qui minimise l'insécurité et la distance à parcourir tout en maximisant l'intérêt  des lieux.
\section{Besoins}
\begin{itemize}
\item Le programme devra retourner une solution de parcours viable rapidement,
\item Le logiciel permettra de retourner une nouvelle solution si on interverti des lieux ou/et si on change l'ordre des lieux à visiter.
\item Le programme doit être simple à utiliser
\item Le programme peut retourner un certain nombre de parcours calculé dans le temps d'exécution impartie.
\end{itemize}

\chapter{Modélisation du problème}

\section{Variables}
Il y a des paramètres sur la configuration de la ville qui vont être importants à prendre en compte car ils vont influencer les résultats ce sont les variables.
Un variable qui dépend de l'utilisateur c'est l'intérêt des différends lieux de la ville. Par exemple pour un même lieu deux utilisateurs vont pas lui attribuer obligatoirement le même intérêt.
Les autres variables dont il faut tenir compte sont les caractéristiques des arcs qui sont la distance et l'insécurité.

\section{Contraintes}
La principale contrainte de ce problème est la liaisons entre les différents lieux, c'est à dire si il existe un ou plusieurs arc entre deux lieux pour pouvoir aller d'un lieu dit source à un lieu dit destination.
Si on reprend la configuration présenter dans la figure  on voit que pour aller du lieu de départ (0) au lieu A ou E il faut passer par le lieu B.
En d'autre termes pour réaliser le parcourt on peut se déplacer d'un lieu à un autre si il existe au moins un arc reliant les deux lieux en question.
 
\section{Fonctions Objectifs}

Pour notre problème on peu considérer plusieurs fonctions objectifs qui sont les suivantes :
\begin{itemize}
\item[1\iere{} fonction :]Il faut que l'ensemble des lieux soit visités en essayant de maximiser l'intérêt
\item[2\ieme{} fonction :]Le parcourt doit minimiser la distance
\item[3\ieme{} fonction :]Le parcourt doit aussi minimiser l'insécurité
\end{itemize} 

\chapter{Spécification}
Maintenant que nous avons réaliser la définition et la modélisation du problème a été effectué, on va chercher à spécifier le programme qui permettra de répondre au problème et à définir de manière concise la structure général de ce programme.

\section{Délimitation système/environnement}

On peu représenter cette délimitation à l'aide du schéma ci-dessous
\begin{figure}[h]
\begin{center}
\includegraphics{environnement.jpg}
\caption{Schéma représentant la délimitation système/environnement}
\label{fig:Schéma représentant la délimitation système/environnement}
\end{center}
\end{figure}

En plus de distinguer le système de l'environnement le schéma précèdent nous permet de voir en même temps les flux d'informations entre les différentes identités de l'environnement.
\begin{itemize}
\item La flèche entre l'utilisateur et le fichier texte représente le processus par lequel l'utilisateur rentre la configuration de la ville, c'est à dire la position des lieux avec leur intérêt pour l'utilisateur et les arcs avec leurs caractéristiques.
\item Le fichier texte une fois remplis par l'utilisateur sert d'entré au programme pour créer la structure de données
\item Une fois que le programme a finis de tourner il retourne à l'utilisateur la liste des parcours possible par rapport à la ville qui a été rentré dans la fichier texte.
\end{itemize}

\section{Définition du programme à réaliser}

Pour réaliser un programme qui permet de répondre au mieux au besoins nous avons séparer le problème en 4-5 partie : 
\begin{enumerate}
\item Pour gérer la configuration des lieux qui provient du fichier texte prévu comme entrée, il faut un ensemble de structure de données qui permet de stocker et d'utiliser les différents paramètre lier à la configuration, c'est à dire :   l'intérêt des lieux, l'intercommunication entre les différents lieux, les arcs qui permette cette communication et les caractéristiques de ces arc (Distance, Insécurité).
\item Générer un chemin de base
\item Générer de nouveaux chemin en réalisant des permutations dans le chemin de base en fonction des permutations possible entre les lieux.
\item Avoir un structure permettant de retourner les chemins générer
\end{enumerate}

On peut représenter de manière simplifier la structure générale du programme qui répondra au problème posé : 

\section {Lien entre les différentes partie}

\textcolor{blue}{diagramme de classe}

\part{Algorithimique}
Une fois tout l'étape de définition du problème et du contexte, ainsi que de modélisation du programme qui permetterai de répondre au problème.
Nous avons pu commencer la partie réalisation d'algorithme et structure de données qui permette de répondre au problème.
Cette partie a pour but de présenter le principe de fonctionnement du programme. Dans un premier temps, elle traite de la gestion des données fournies par l'utilisateur. Et dans une seconde phase, il sera question de la recherche de résultats. 
Le but étant toujours de tenir compte des fonctions objectifs :
\begin{itemize}
\item L'intérêt des lieux visité doit être maximisé.
\item L'insécurité et la distance du trajet sont à minimiser.
\end{itemize}

Chaque lieu est relié par un ou plusieurs chemins et le retour sur des lieux déjà visités est autorisé. Comme le programme duplique les chemins en mémoire de manière à ce qu'il devienne unidirectionnel, nous ne parlerons plus de chemin pour relier les lieux, mais d'arc.
Par abus de langage, nous utiliserons le terme  "chemin" comme équivalant à "trajet". Ils désignent tous deux un résultat.\\


\chapter{Gestion des données en mémoire}

\section{Données à mémoriser}
L'utilisateur fournit les informations aux programmes par l'intermédiaire d'un fichier texte. Ce document répond à une structure particulière : 
\begin{itemize}
\item Il est constitué de trois parties : Paramètres, Lieux, Arcs.
\item Le nom des parties commence par un dièse et se termine par un saut de ligne.
\item Les commentaires sont précédés du symbole pourcent et sont placés avant que commence l'une des trois parties.
\end{itemize}

\subsection{Les paramètres}

Toutes les informations sont contenues sur une seule ligne et séparées par des points virgule.
On retrouve :
\begin{itemize}
\item Temps de recherche en seconds (entier)
\item Nombres de lieux totaux (entier)
\item Nombres d'arcs totaux (entier)
\item \{d$\vert$c\} caractère qui indique si, lors de la réalisation du chemin de référence, les lieux doivent suivre un intérêt croissant ou décroissant (caractère)\\
 \end{itemize}   

\textit{Exemple :}
\begin{verbatim}
	#Parametres
	60;5;11;d
\end{verbatim}	
Indique un temps de recherche de 60s dans un graphe constitué de 5 lieux, 11 chemins.
Le chemin de base doit être constitué suivant un intérêt décroissant.

\subsection{Les lieux}

Les lieux sont caractérisés par trois valeurs et espérés par un retour à la ligne. Le premier lieu est celui de départ de la recherche, il est numéroté zéro et possède un intérêt nul.\\
Paramètres des lieux : 
\begin{itemize}
\item Numéro : commence à partir de zéro et s'incrémente d'un à chaque lieu. (entier)
\item Intérêt : indique la valeur d'intérêt du lieu. (entier)
\item Nom du lieu : le nom du lieu (chaine de caractères)\\
\end{itemize}
\newpage
\textit{Exemple :}
\begin{verbatim}
	# Lieux
	0;0;Départ
	1;6;L1
	2;2;L2
	3;12;L3
	4;1;L4
\end{verbatim}
Il y a 5 lieux numérotés de zéro à quatre possédant chacun un intérêt est un nom.

\subsection{Les Arcs}
Les arcs sont séparés par des retours à la lignes, ils sont constitués de quatre paramètres :
\begin{itemize}
\item Le numéro de lieu de départ (entier)
\item Le numéro du lieu d'arrivée (entier)
\item Sa distance (entier)
\item Son insécurité (entier)\\
\end{itemize}

\textit{Exemple :}
\begin{verbatim}
	# Arcs
	0;3;10;1
	0;3;7;2
	0;3;8;3
	0;3;1;2
	0;2;7;9
	0;1;6;3
	0;1;2;5
	2;3;2;2
	2;1;7;1
	2;1;6;2
	2;1;5;3
	2;4;8;8
	2;4;9;9
	4;1;1;9
\end{verbatim}

On retrouve ici 11 arcs, tous reliant des lieux et possédant une distance et une insécurité.\\

Les exemples précédents permettent de créer une ville de cette forme :
\begin{figure}[h]
\begin{center}
\includegraphics{graphe1.png}
\caption{Schéma représentant la configuration}
\label{fig:Schéma représentant la configuration}
\end{center}
\end{figure}

\section{Mémorisation des informations}

Toutes les informations utiles au programme sont contenues dans une structure principales nommée "Donnee", cela permet d'avoir un programme ordonné, avec une seule variable à passer en paramètre aux fonctions

\subsection{Structure de "Donnee"}

\begin{itemize}
\item parametres (Parametres)
\item liste\_lieu (Coef\_lieu)
\item lieu (Lieu)
\item index\_lieu (Index\_arc)
\item map (Arc)
\item resultat (Resultats)
\item solution (Solution)
\end{itemize}
On va détailler les informations contenues dans cette structure dans les parties suivant.

\subsection{Les paramètres de la recherche}
La structure "Parametre" contient les informations sur la recherche, voir la partie correspondante pour plus d'information.

Structure Parametres :\\
\begin{itemize}
\item temps\_execution (entier)
\item nb\_lieux (entier)
\item nb\_arcs (entier)
\item ordre\_lieu (caractère)
\end{itemize}

\subsection{La gestion des lieux dans la mémoire}
Les lieux sont contenus dans un tableau "lieux" de type "lieu" qui est accessible de puis la structure générale. Il y a sont stockés en fonction de leur apparition dans le fichier de données. Le tableau est donc ordonné en fonction de leur numéro.\\
La structure "lieu" est utilisée pour contenir toutes les informations relatives à un lieu, ref section correspodante.\\

Structure Lieu :\\
\begin{itemize}
\item id (entier)
\item interet (entier)
\item nom (chaine de caractères)
\item nb\_arc (entier)
\end{itemize}

On détaille cette structure de cette manière :\\
\begin{itemize}
\item id : fait référence au numéro du lieu du fichier de donnée.
\item interet : valeur
\item nom : celui du lieu
\item nb\_arc : nombre d'arc sortant de ce lieu
\end{itemize}

\subsection{La gestion des lieux pour le chemin de base}

Comme le solver doit fournir des solutions comportant les chemins intermédiaires, il est nécessaire de pouvoir rajouter rapidement un lieu au chemin de référence dès que la recherche pour n lieux est terminée.\\
Pour éviter d'avoir à parcourir la liste des lieux à chaque ajout, le tableau liste\_lieu de paramètre ordre\_lieu renseigné par l'utilisateur.

\subsection{La gestion des arcs}

Tous les chemins décrits dans le fichier sont dupliqués de manière à devenir unidirectionnelle, c'est pourquoi l'on parle d'arc.\\
Ils sont contenus dans un tableau à trois dimensions nommé "map", de type "Arc" et est accessible depuis la structure générale. La première dimensions permet de pointer les arcs stockés en mémoire. La troisième dimension est l'arc lui-même. Cette table est ainsi construite afin de permettre les tris et la suppression des arcs dominés.\\
La structure "Arc" est utilisé pour contenir toutes les informations définissant un arc. Voir partie sur arc pour plus d'information.\\

Structure Arc :\\
\begin{itemize}
\item distance (entier)
\item insecurite (entier)
\item depart (entier)
\item destination (pointeur lieu)
\end{itemize}

Le départ et la destination sont des pointeurs sur les structure de type "lieu" détenues par lieux de la structure data. Faire cette référence évite de surcharger la mémoire d'informations redondantes.\\

Voici a quoi doit ressembler la table "map" après suppression des arcs dominés dans l'exemple du chapitre précédent.
\begin{figure}[h]
\begin{center}
\includegraphics{map.jpg}
\caption{Schéma représentant la structure "map"}
\label{fig:Schéma représentant la structure "map"}
\end{center}
\end{figure}

\subsection{Relation entre le lieu de départ et le lieu d'arrivée}

Le tableau "map" indique déjà le lieu de départ, mais comme le nombre d'arcs entre les lieux est variables, seul le parcourt des dimensions deux et trois permet de connaitre le lieu de destination. C'est pour éviter cette recherche que l'on créé une table d'index nommé "index\_lieu" de type "index\_arc" et accessible depuis la structure "Donnee".
Il s'agit d'un tableau carré, utilisé comme une tableau à deux entrées (le lieu de départ et le lieu d'arrivée). La structure "index\_arc" permet de savoir combien d'arcs ces lieux ont en commun et contiens l'identifiant du premier arc utile dans le tableau map[lieu\_depart].

Structure index\_arc :\\
\begin{itemize}
\item {itemize} id\_arc (entier)
\item {itemize} nb\_arc (entier)
\end{itemize}
Voici une représentation possible de la table index\_lieu et des structures Inde\_arc. Les adresses en mémoire sont fictives. 

\begin{figure}[h]
\begin{center}
\includegraphics{index.jpg}
\caption{Schéma représentant la structure}
\label{fig:Schéma représentant la structure}
\end{center}
\end{figure}

\subsection{La gestion des solutions}

Le tableau des solutions était prévu pour contenir les solutions obtenus après la recherche. Mais cela posait des problèmes avec l'algorithme permettant de générer tous les chemins avec les différents arcs.\\
C'est pour cela que cette table est maintenant utilisée comme une pile de résultats intermédiaires, nommés "solution", pour qui tous les chemins non pas encore étaient généré.\\
Cette table nommée "solution", de type "solutions" et accesible dans la structure "Donnee"\\
La structure "solution" permet de contenir tous les chemins obtenus grâce aux algorithmes de recherche. Elle contient le nombres de solutions disponibles dans cette table est un tableau nommé "solutions" de type "Parcourt".\\
La structure "parcourt" définit un résultat, une partie "carac" de type "caractéristique" contient les informations générales sur la solution, un tableau "trajet" contient tous les arcs utilisés dans l'ordre de parcourt. "Itiniaire" est l'équivalent de trajet, mais pour les lieux, quant à la table "visite", elle n'est utilisée que par l'algorithme de génération du chemin de base pour savoir quel lieu est déjà présent sur le chemin.\\
La structure "caractéristique" contient les informations globales de la solution. C'est à dire, l'intérêt, la distance, l'insécurité, le nombre de lieux total, le nombre de lieux utile et le nombre d'arcs du chemin.\\

Structure Solutions :\\
\begin{itemize}
\item nb\_solution (entier)
\item solution (pointeur Parcourt)\\
\end{itemize}

Structure Parcourt :\\
\begin{itemize}
\item Carac (Caracteristique)
\item Trajet (pointeur Arc)
\item Itineraire (pointeur Lieu)
\item visite (entier)\\
\end{itemize}

Structure Caracteristique :\\
\begin{itemize}
\item interet (entier)
\item distance (entier)
\item insecurite (entier)
\item nb\_lieux\_utile (entier)
\item nb\_lieux\_total (entier)
\item nb\_arc (entier)
\end{itemize}

\subsection{La gestion des résultats}

L'entrer "resultat" de type "resultat" est disponible dans la structure "Donnee" elle contient, dans le tableau "résultats", les chemins non dominés et dont toutes les possibilités au niveau de la permutation des arcs ont été testées.\\
Afin de disposer de résultat ordonnés et pour faciliter l'algorithme de suppression des chemins dominés et identiques, le tableau "résultats" de type "parcourt" est à trois dimensions. Une première dimension permet de classer les chemins en fonction du nombre de lieux total, la deuxième dimension est un pointeur sur le résultat.\\
Comme cette structure est entièrement dynamique, la structure "résultats" dispose d'un entier nommé "nb\_lieu" qui indique le nombre de lieux constituant un chemin qui est géré par la table "resultat" mais aussi un tableau nommé "nb\_resultat" qui indique le nombre de chemins alloués et le nombre de chemins utilisés en fonction du nombre de lieux.\\

Structure resultat :\\
\begin{itemize}
\item nb\_lieux (entier)
\item nb\_resultats (entier)
\item resultats (pointeur Parcourt)
\end{itemize}

\chapter{Algo de tri rapide multicritères}

\algsetup{indent=3em}
\begin{algorithm}
\caption{Swap}
\label{Swap}
\begin{algorithmic}[1]
\REQUIRE  ~\\
Entrée : $X,Y$  pointeur sur des Arcs\\
$X et Y$  sont des pointeurs valides
\ENSURE ~\\
Sortie :$\emptyset$ \\
$X$ = $Y'$ et $Y$=$X'$\\
 \STATE Allouer(tmp)\\
 \STATE tmp $\gets$ $\uparrow$X\\
 \STATE $\uparrow$X $\gets$ $\uparrow$Y\\
 \STATE $\uparrow$Y $\gets$ tmp
\end{algorithmic}
\end{algorithm}

\algsetup{indent=3em}
\begin{algorithm}
\caption{Quicksort\_map}
\label{Quicksort_map}
\begin{algorithmic}[1]
\REQUIRE  ~\\
Entrée : \begin{itemize}
\item data pointeur sur la structure Donner\\
\item id\_Lieu entier, identifiant du lieu a trier\\
\item $m$ entier borne droit du tri\\
\item	$n$ entier  borne gauche du tri\\
\end{itemize}
Toutes les données sont valides
\ENSURE ~\\
Sortie : $\emptyset$ \\
Postcondition : data  $\to$ map[id\_lieu] est trier par : \begin{itemize}
\item IntérÕt décroissant
\item Distance croissant
\item Insécurité croissant
\end{itemize}
\IF {$(m<n)$}
   \STATE $k$ $\gets$ $($m$+$n$)/2$
   \STATE swap (map[m],map[n])
   \STATE $i$ $\gets$ $m+1$
   \STATE $j$ $\gets$ $n$
   \WHILE {$i \leq j$}     
        \WHILE {$((i \leq n)$ \& $position(data, id\_lieu,i,m)$}
	  \STATE $i \gets i+1$
        \ENDWHILE
        \WHILE {$((j \leq n)$ \& $position(data,id\_lieu,j,m)$}
            \STATE $j \gets j+1$
        \ENDWHILE
        \IF {$(i < j)$}
          \STATE swap (map[i],map[j])
        \ENDIF
   \ENDWHILE     
        \STATE swap(map[m],map[j])
        \STATE quicksort\_map(data,id\_lieu,m,j-1)
        \STATE quicksort\_map(data,id\_lieu,j+1,n)
\ENDIF
\end{algorithmic}
\end{algorithm}

\algsetup{indent=3em}
\begin{algorithm}
\caption{Position}
\label{Position}
\begin{algorithmic}[1]
\REQUIRE  ~\\
Entrée : \begin{itemize}
\item data pointeur sur la structure donnée\\
\item id\_lieu entier, identifiant du lieu a trier\\
\item id\_arc entier, identifiant de l'arc\\
\item	id\_key entier, identifiant de la clef\\
\end{itemize}
Toutes les données doivent être valides
\ENSURE ~\\
Sortie : posi est un booléen \\
\begin{itemize}
\item posi = 0 : id\_arc avant id\_key
\item posi = 1 : id\_arc après id\_key
\end{itemize}
\STATE Key\_interet $\gets$ interet\_destination (data,id\_lieu,id\_key) 
\STATE Key\_distance $\gets$ distance\_arc (data,id\_lieu,id\_key)
\STATE Key\_insecurite $\gets$ insecurite\_arc (data,id\_lieu,id\_key)
\STATE arc\_interet $\gets$ insecurite\_arc (data,id\_lieu,id\_arc)
\STATE arc\_distance $\gets$ insecurite\_arc (data,id\_lieu,id\_arc) 
\STATE arc\_insecurite $\gets$ insecurite\_arc (data,id\_lieu,id\_arc) 
\STATE $posi = 1$
\IF {$(arc\_interet > key\_interet)$}
	\STATE $posi=0$
\ENDIF
\IF {$(posi \ne 0)$ et $(arc\_interet = key\_interet)$}
	\IF {$(arc\_distance < key\_distance)$}
		\STATE $posi = 0$
	\ENDIF
	\IF {$(posi \ne 0)$ et $(arc\_distance = key\_distance)$}
		\IF {$(arc\_insecurite \le key\_insecurite)$}
			\STATE $posi = 0$
		\ENDIF	
	\ENDIF
\ENDIF
\STATE retourner(posi)		
\end{algorithmic}
\end{algorithm}

\newpage
\section{Création de chemin}

\algsetup{indent=3em}
\begin{algorithm}
\caption{Permutation}
\label{Permutation}
\begin{algorithmic}[1]
\REQUIRE ~\\
\ENSURE ~\\
\STATE Cpy\_Solution(data,Id\_Solution\_base,Id\_Solution\_New);
 \FOR{$i$ {\textbf du} 1\ier{}lieu \textbf{au} dernier lieu}
  	\IF {$Permutation\_Possible(i+2,i+1) = 1$}
		\STATE $tmp \gets lieu[i+2];$
		\STATE $lieu[i+2] \gets lieu[i+1];$
		\STATE $lieu[i+1] \gets tmp;$
		\STATE Sortie de la boucle
	\ELSE
		\STATE Retourner("Il n'y a pas de permutation possible")
	\ENDIF
\ENDFOR
\STATE Retourner(Le nouveau chemin)
\end{algorithmic}
\end{algorithm}
		
\chapter{Conclusion}



\annexes
\chapter{Fiche de suivi de projet\label{sec:fiche_suivi}}

\CR{17/01/2011}{1ére rencontre avec Emmanuel Néron pour prendre une explication approfondi du sujet ainsi que le premier objectif à réaliser qui est le choix d'une structure de donnée pour gérer les villes.}
\CR{20/02/2011  au 04/03/2011}{Réflexion sur les méthodes possible pour la structure de donnée à mettre en place, ainsi que les algorithmes à utiliser pour parcourir les différentes structures de données}
\CR{04/03/2011 au 29/03/2011}{Réalisation de la structure de données pour gérer la configuration de la ville, mise en place d'algorithme de tri pour les arcs.}
\CR{07/04/2011}{Finalisation de la structure de données, vérification des fonctions permettant d'interroger la structure de données pour les algorithmes permettant de créé les trajets, première réalisation d'un algorithme pour générer le trajet de référence.}
\CR{11/04/2011}{Réunion avec notre encadrant pour lui présenter la structure de données et l'esquisse de l'algorithme pour générer le trajets de référence.}
\CR{11/04/2011 au 05/05/2011}{Réalisation et implémentation de l'algorithme pour générer un chemin de base et résolution d'un problème par rapport au tri des arc entre les lieux.}
\CR{05/05/2011 au 01/06/2011}{}
%\CR{XX/XX/2008}{validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats	validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats.}
%\CR{XX/XX/2008}{validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats	validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats.}
%\CR{XX/XX/2008}{validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats	validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats.}
%\CR{XX/XX/2008}{validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats	validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats.}
%\CR{XX/XX/2008}{validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats	validation du planning, installation et évaluation du logiciel XX, essais sur le jeu de données fourni, présentation orale des résultats.}


\end{document}

