\documentclass[twoside]{EPURapport}
\input{include.tex}

\thedocument{Rapport Projet Algorithme-C}{Tournée d'un véhicule multicritères}%{Titre court}

\grade{Département Informatique\\ 3\ieme{} année\\ 2010 - 2011}

\authors{%
	\category{Étudiants}{%
		\name{Cyrille PICARD} \mail{cyrille.picard@etu.univ-tours.fr}
		\name{Michael PURET} \mail{michael.puret@etu.univ-tours.fr}
	}
	\details{DI3 2010 - 2011}
}

\supervisors{%
	\category{Encadrant}{%
		\name{Emmanuel Neron} \mail{emmanuel.neron@univ-tours.fr}
	}
	\details{Université François-Rabelais, Tours}
}

\abstracts{Projets d'algorithmique et langage C de 3ème année portant sur la réalisation d'une solution permettant de calculer des parcours entre des lieux en fonction de certaines contraintes}
{Calcul de parcours, Lieux, }
{Description en anglais}
{Mots clés en anglais}


\begin{document}


\chapter{Introduction}

Pour ce projet nous intéressons à réaliser un programme qui permet en fonction d'une liste de lieux de ressortir la liste des différents parcours possible pour réaliser cette tournée entre les différents lieux. Ce problème est un peu similaire à celui du voyageur de commerce. 
Le principe de l'application qu'on essaye de développer est de permettre à partir d'une Base de données représentant la configuration d'une ville.
C'est à dire un ensemble de lieux relié entre par des arcs, de calculer un parcours pour passer par tout les lieux en fonction de leur intérêt pour l'utilisateur.
La difficulté majeur est de retourner des solutions dans une  période très courte. 

\begin{figure}[h]
\begin{center}
\includegraphics{graph.jpg}
\caption{Représentation simplifiée de la configuration}
\label{fig:Représentation simplifiée de la configuration}
\end{center}
\end{figure}

\part{Spécification}
\chapter{Cahier des charges}

Suite à la première rencontre avec notre encadrant un premier cahier des charges a été évoquer. Le logiciel doit retourner la liste des différents parcours possible pour visiter une série de lieux dans l'ordre désiré par l'utilisateur. Le but est de calculer un parcours qui minimise l'insécurité et la distance à parcourir tout en maximisant l'intérêt  des lieux.
\section{Besoins}
\begin{itemize}
\item Le programme devra retourner une solution de parcours viable rapidement,
\item Le logiciel permettra de retourner une nouvelle solution si on interverti des lieux ou/et si on change l'ordre des lieux à visiter.
\item Le programme doit être simple à utiliser
\item Le programme peut retourner un certain nombre de parcours calculé dans le temps d'exécution impartie.
\end{itemize}

\chapter{Modélisation du problème}

\section{Variables}
Il y a des paramètres sur la configuration de la ville qui vont être importants à prendre en compte car ils vont influencer les résultats ce sont les variables.
Un variable qui dépend de l'utilisateur c'est l'intérêt des différends lieux de la ville. Par exemple pour un même lieu deux utilisateurs vont pas lui attribuer obligatoirement le même intérêt.
Les autres variables dont il faut tenir compte sont les caractéristiques des arcs qui sont la distance et l'insécurité.

\section{Contraintes}
La principale contrainte de ce problème est la liaisons entre les différents lieux, c'est à dire si il existe un ou plusieurs arc entre deux lieux pour pouvoir aller d'un lieu dit source à un lieu dit destination.
Si on reprend la configuration présenter dans la figure  on voit que pour aller du lieu de départ (0) au lieu A ou E il faut passer par le lieu B.
En d'autre termes pour réaliser le Parcours on peut se déplacer d'un lieu à un autre si il existe au moins un arc reliant les deux lieux en question.
 
\section{Fonctions Objectifs}

Pour notre problème on peu considérer plusieurs fonctions objectifs qui sont les suivantes :
\begin{itemize}
\item[1\iere{} fonction :]Il faut que l'ensemble des lieux soit visités en essayant de maximiser l'intérêt
\item[2\ieme{} fonction :]Le Parcours doit minimiser la distance
\item[3\ieme{} fonction :]Le Parcours doit aussi minimiser l'insécurité
\end{itemize} 

\chapter{Spécification}
Maintenant que nous avons réaliser la définition et la modélisation du problème a été effectué, on va chercher à spécifier le programme qui permettra de répondre au problème et à définir de manière concise la structure général de ce programme.

\section{Délimitation système/environnement}

On peu représenter cette délimitation à l'aide du schéma ci-dessous
\begin{figure}[h]
\begin{center}
\includegraphics{environnement.jpg}
\caption{Schéma représentant la délimitation système/environnement}
\label{fig:Schéma représentant la délimitation système/environnement}
\end{center}
\end{figure}

En plus de distinguer le système de l'environnement le schéma précèdent nous permet de voir en même temps les flux d'informations entre les différentes identités de l'environnement.
\begin{itemize}
\item La flèche entre l'utilisateur et le fichier texte représente le processus par lequel l'utilisateur rentre la configuration de la ville, c'est à dire la position des lieux avec leur intérêt pour l'utilisateur et les arcs avec leurs caractéristiques.
\item Le fichier texte une fois remplis par l'utilisateur sert d'entré au programme pour créer la structure de données
\item Une fois que le programme a finis de tourner il retourne à l'utilisateur la liste des parcours possible par rapport à la ville qui a été rentré dans la fichier texte.
\end{itemize}

\section{Définition du programme à réaliser}

Pour réaliser un programme qui permet de répondre au mieux au besoins nous avons séparer le problème en 4-5 parties : 
\begin{enumerate}
\item Pour gérer la configuration des lieux qui provient du fichier texte prévu comme entrée, il faut un ensemble de structure de données qui permet de stocker et d'utiliser les différents paramètre lier à la configuration, c'est à dire :   l'intérêt des lieux, l'intercommunication entre les différents lieux, les arcs qui permette cette communication et les caractéristiques de ces arc (Distance, Insécurité).
\item Générer un chemin de base
\item Générer de nouveaux chemin en réalisant des permutations dans le chemin de base en fonction des permutations possible entre les lieux.
\item Avoir un structure permettant de retourner les chemins générer
\end{enumerate}

On peut représenter de manière simplifier la structure générale du programme qui répondra au problème posé : 



\part{Algorithimique}

\chapter{Principe de fonctionnement du programme}
Une fois tout l'étape de définition du problème et du contexte, ainsi que de modélisation du programme qui permetterai de répondre au problème.
Nous avons pu commencer la partie réalisation d'algorithme et structure de données qui permette de répondre au problème.
Cette partie a pour but de présenter le principe de fonctionnement du programme. Dans un premier temps, elle traite de la gestion des données fournies par l'utilisateur. Et dans une seconde phase, il sera question de la recherche de résultats. 
Le but étant toujours de tenir compte des fonctions objectifs :
\begin{itemize}
\item L'intérêt des lieux visité doit être maximisé.
\item L'insécurité et la distance du trajet sont à minimiser.
\end{itemize}

Chaque lieu est relié par un ou plusieurs chemins et le retour sur des lieux déjà visités est autorisé. Comme le programme duplique les chemins en mémoire de manière à ce qu'il devienne unidirectionnel, nous ne parlerons plus de chemin pour relier les lieux, mais d'arc.
Par abus de langage, nous utiliserons le terme  "chemin" comme équivalant à "trajet". Ils désignent tous deux un résultat.\\


Exécution du programme étape par étape :\\
\begin{enumerate}
\item L?utilisateur fournit l?ensemble des données au programme par l?intermédiaire d?un fichier texte. Celui-ci est passé dans les paramètres lors lancement du solveur.
\item Le programme mémorise l?ensemble des informations.
\item Il y a un tri et une suppression des informations erronées.
\item Le programme recherche le chemin de référence en ajoutant un lieu de plus au parcours déjà existant.
\item Le chemin de référence est utilisé pour produire des solutions optimisées, placées dans la pille en vue d?un traitement final.
\item Les solutions sont dépilées, l?ensemble des possibilités est calculé et enregistré un tableau de résultats classé par nombre de lieux.
\item On remonte au point 4 tant que tous les lieux ne sont pas dans la solution et qu?il reste du temps de recherche.
\item On affiche les résultats sur la sortie standard.\\
\end{enumerate}

\begin{figure}[h]
\begin{center}
\includegraphics[height=22cm, width=18cm]{srtucture.png}
\caption{Schéma représentant le principe de fonctionnement du programme}
\label{fig:Schéma représentant le principe de fonctionnement du programme}
\end{center}
\end{figure}

Pour récupérer les résultats dans un fichier texte, il suffit de rediriger la sortie standard vers le fichier de résultats. Sous Window comme sous Linux, la redirection se fait avec le symbole supérieur.\\
\textit{Exemple :}
\begin{verbatim}

\$ : nom_du_programe [parametre(s)] > chemin_du_fichier

\end{verbatim}


\chapter{Gestion des données en mémoire}

\section{Données à mémoriser}
L'utilisateur fournit les informations aux programmes par l'intermédiaire d'un fichier texte. Ce document répond à une structure particulière : 
\begin{itemize}
\item Il est constitué de trois parties : Paramètres, Lieux, Arcs.
\item Le nom des parties commence par un dièse et se termine par un saut de ligne.
\item Les commentaires sont précédés du symbole pourcent et sont placés avant que commence l'une des trois parties.
\end{itemize}

\subsection{Les paramètres}

Toutes les informations sont contenues sur une seule ligne et séparées par des points virgule.
On retrouve :
\begin{itemize}
\item Temps de recherche en seconds (entier)
\item Nombres de lieux totaux (entier)
\item Nombres d'arcs totaux (entier)
\item \{d$\vert$c\} caractère qui indique si, lors de la réalisation du chemin de référence, les lieux doivent suivre un intérêt croissant ou décroissant (caractère)\\
 \end{itemize}   

\textit{Exemple :}
\begin{verbatim}
	#Parametres
	60;5;11;d
\end{verbatim}	
Indique un temps de recherche de 60s dans un graphe constitué de 5 lieux, 11 chemins.
Le chemin de base doit être constitué suivant un intérêt décroissant.

\subsection{Les lieux}

Les lieux sont caractérisés par trois valeurs et espérés par un retour à la ligne. Le premier lieu est celui de départ de la recherche, il est numéroté zéro et possède un intérêt nul.\\
Paramètres des lieux : 
\begin{itemize}
\item Numéro : commence à partir de zéro et s'incrémente d'un à chaque lieu. (entier)
\item Intérêt : indique la valeur d'intérêt du lieu. (entier)
\item Nom du lieu : le nom du lieu (chaine de caractères)\\
\end{itemize}
\newpage
\textit{Exemple :}
\begin{verbatim}
	# Lieux
	0;0;Départ
	1;6;L1
	2;2;L2
	3;12;L3
	4;1;L4
\end{verbatim}
Il y a 5 lieux numérotés de zéro à quatre possédant chacun un intérêt est un nom.

\subsection{Les Arcs}
Les arcs sont séparés par des retours à la lignes, ils sont constitués de quatre paramètres :
\begin{itemize}
\item Le numéro de lieu de départ (entier)
\item Le numéro du lieu d'arrivée (entier)
\item Sa distance (entier)
\item Son insécurité (entier)\\
\end{itemize}

\textit{Exemple :}
\begin{verbatim}
	# Arcs
	0;3;10;1
	0;3;7;2
	0;3;8;3
	0;3;1;2
	0;2;7;9
	0;1;6;3
	0;1;2;5
	2;3;2;2
	2;1;7;1
	2;1;6;2
	2;1;5;3
	2;4;8;8
	2;4;9;9
	4;1;1;9
\end{verbatim}

On retrouve ici 11 arcs, tous reliant des lieux et possédant une distance et une insécurité.\\

Les exemples précédents permettent de créer une ville de cette forme :
\begin{figure}[h]
\begin{center}
\includegraphics{graphe1.png}
\caption{Schéma représentant la configuration}
\label{fig:Schéma représentant la configuration}
\end{center}
\end{figure}

\section{Mémorisation des informations}

Toutes les informations utiles au programme sont contenues dans une structure principales nommée "Donnee", cela permet d'avoir un programme ordonné, avec une seule variable à passer en paramètre aux fonctions

\subsection{Structure de "Donnee"}

\begin{itemize}
\item parametres (Parametres)
\item liste\_lieu (Coef\_lieu)
\item lieu (Lieu)
\item index\_lieu (Index\_arc)
\item map (Arc)
\item resultat (Resultats)
\item solution (Solution)
\end{itemize}
On va détailler les informations contenues dans cette structure dans les parties suivant.

\subsection{Les paramètres de la recherche}
La structure "Parametre" contient les informations sur la recherche, voir la partie correspondante pour plus d'information.

Structure Parametres :\\
\begin{itemize}
\item temps\_execution (entier)
\item nb\_lieux (entier)
\item nb\_arcs (entier)
\item ordre\_lieu (caractère)
\end{itemize}

\subsection{La gestion des lieux dans la mémoire}
Les lieux sont contenus dans un tableau "lieux" de type "lieu" qui est accessible de puis la structure générale. Il y a sont stockés en fonction de leur apparition dans le fichier de données. Le tableau est donc ordonné en fonction de leur numéro.\\
La structure "lieu" est utilisée pour contenir toutes les informations relatives à un lieu, ref section correspodante.\\

Structure Lieu :\\
\begin{itemize}
\item id (entier)
\item interet (entier)
\item nom (chaine de caractères)
\item nb\_arc (entier)
\end{itemize}

On détaille cette structure de cette manière :\\
\begin{itemize}
\item id : fait référence au numéro du lieu du fichier de donnée.
\item interet : valeur
\item nom : celui du lieu
\item nb\_arc : nombre d'arc sortant de ce lieu
\end{itemize}

\subsection{La gestion des lieux pour le chemin de base}

Comme le solver doit fournir des solutions comportant les chemins intermédiaires, il est nécessaire de pouvoir rajouter rapidement un lieu au chemin de référence dès que la recherche pour n lieux est terminée.\\
Pour éviter d'avoir à parcourir la liste des lieux à chaque ajout, le tableau liste\_lieu de paramètre ordre\_lieu renseigné par l'utilisateur.

\subsection{La gestion des arcs}

Tous les chemins décrits dans le fichier sont dupliqués de manière à devenir unidirectionnelle, c'est pourquoi l'on parle d'arc.\\
Ils sont contenus dans un tableau à trois dimensions nommé "map", de type "Arc" et est accessible depuis la structure générale. La première dimensions permet de pointer les arcs stockés en mémoire. La troisième dimension est l'arc lui-même. Cette table est ainsi construite afin de permettre les tris et la suppression des arcs dominés.\\
La structure "Arc" est utilisé pour contenir toutes les informations définissant un arc. Voir partie sur arc pour plus d'information.\\

Structure Arc :\\
\begin{itemize}
\item distance (entier)
\item insecurite (entier)
\item depart (entier)
\item destination (pointeur lieu)
\end{itemize}

Le départ et la destination sont des pointeurs sur les structure de type "lieu" détenues par lieux de la structure data. Faire cette référence évite de surcharger la mémoire d'informations redondantes.\\

Voici a quoi doit ressembler la table "map" après suppression des arcs dominés dans l'exemple du chapitre précédent.
\begin{figure}[h]
\begin{center}
\includegraphics{map.jpg}
\caption{Schéma représentant la structure "map"}
\label{fig:Schéma représentant la structure "map"}
\end{center}
\end{figure}

\subsection{Relation entre le lieu de départ et le lieu d'arrivée}

Le tableau "map" indique déjà le lieu de départ, mais comme le nombre d'arcs entre les lieux est variables, seul le Parcours des dimensions deux et trois permet de connaitre le lieu de destination. C'est pour éviter cette recherche que l'on créé une table d'index nommé "index\_lieu" de type "index\_arc" et accessible depuis la structure "Donnee".
Il s'agit d'un tableau carré, utilisé comme une tableau à deux entrées (le lieu de départ et le lieu d'arrivée). La structure "index\_arc" permet de savoir combien d'arcs ces lieux ont en commun et contiens l'identifiant du premier arc utile dans le tableau map[lieu\_depart].

Structure index\_arc :\\
\begin{itemize}
\item {itemize} id\_arc (entier)
\item {itemize} nb\_arc (entier)
\end{itemize}
Voici une représentation possible de la table index\_lieu et des structures Inde\_arc. Les adresses en mémoire sont fictives. 

\begin{figure}[h]
\begin{center}
\includegraphics{index.jpg}
\caption{Schéma représentant la structure}
\label{fig:Schéma représentant la structure}
\end{center}
\end{figure}

\subsection{La gestion des solutions}

Le tableau des solutions était prévu pour contenir les solutions obtenus après la recherche. Mais cela posait des problèmes avec l'algorithme permettant de générer tous les chemins avec les différents arcs.\\
C'est pour cela que cette table est maintenant utilisée comme une pile de résultats intermédiaires, nommés "solution", pour qui tous les chemins non pas encore étaient généré.\\
Cette table nommée "solution", de type "solutions" et accesible dans la structure "Donnee"\\
La structure "solution" permet de contenir tous les chemins obtenus grâce aux algorithmes de recherche. Elle contient le nombres de solutions disponibles dans cette table est un tableau nommé "solutions" de type "Parcours".\\
La structure "Parcours" définit un résultat, une partie "carac" de type "caractéristique" contient les informations générales sur la solution, un tableau "trajet" contient tous les arcs utilisés dans l'ordre de Parcours. "Itiniaire" est l'équivalent de trajet, mais pour les lieux, quant à la table "visite", elle n'est utilisée que par l'algorithme de génération du chemin de base pour savoir quel lieu est déjà présent sur le chemin.\\
La structure "caractéristique" contient les informations globales de la solution. C'est à dire, l'intérêt, la distance, l'insécurité, le nombre de lieux total, le nombre de lieux utile et le nombre d'arcs du chemin.\\

Structure Solutions :\\
\begin{itemize}
\item nb\_solution (entier)
\item solution (pointeur Parcours)\\
\end{itemize}

Structure Parcours :\\
\begin{itemize}
\item Carac (Caracteristique)
\item Trajet (pointeur Arc)
\item Itineraire (pointeur Lieu)
\item visite (entier)\\
\end{itemize}

Structure Caracteristique :\\
\begin{itemize}
\item interet (entier)
\item distance (entier)
\item insecurite (entier)
\item nb\_lieux\_utile (entier)
\item nb\_lieux\_total (entier)
\item nb\_arc (entier)
\end{itemize}

\subsection{La gestion des résultats}

L'entrer "resultat" de type "resultat" est disponible dans la structure "Donnee" elle contient, dans le tableau "résultats", les chemins non dominés et dont toutes les possibilités au niveau de la permutation des arcs ont été testées.\\
Afin de disposer de résultat ordonnés et pour faciliter l'algorithme de suppression des chemins dominés et identiques, le tableau "résultats" de type "Parcours" est à trois dimensions. Une première dimension permet de classer les chemins en fonction du nombre de lieux total, la deuxième dimension est un pointeur sur le résultat.\\
Comme cette structure est entièrement dynamique, la structure "résultats" dispose d'un entier nommé "nb\_lieu" qui indique le nombre de lieux constituant un chemin qui est géré par la table "resultat" mais aussi un tableau nommé "nb\_resultat" qui indique le nombre de chemins alloués et le nombre de chemins utilisés en fonction du nombre de lieux.\\

Structure resultat :\\
\begin{itemize}
\item nb\_lieux (entier)
\item nb\_resultats (entier)
\item resultats (pointeur Parcours)
\end{itemize}

\section{Sauvegarde des données en mémoire}
	L'allocation de la mémoire, la lecture du fichier, la mémorisation des données sont les premières étapes que doit franchir le programme. C'est la fonction main\_create\_db qui est chargée de coordonner ces trois actions. Dans un premier temps, elle créer et initialise la structure de donnée générale ("Donnee"), puis elle en fait de même pour les tables "solutions" et "resultat". Une fois que ces étapes sont franchies, elle ouvre le fichier, le lit et sauvegarde les paramètres, puis les lieux et les arcs.L'ensemble de ses actions ne sont pas directement effectué par cette fonction, elle appelle des sous-fonctions comme :\\
\begin{itemize}
\item init\_solutions : initialise la mémoire pour les solutions\item	init\_resultat : initialise la mémoire pour les solutions\item	ajout\_parametre : mémorise les paramètres \item	ajout\_lieux : mémorise les lieux\item ajout\_arc : mémorise les arcs\item create\_liste : créer un tableau des lieux trié avec la méthode du "quicksort" en fonction d? "ordre\_lieu".\item create\_index : créer et remplie la table mettant en relation les arcs est les lieux.
\end{itemize}
Les fonctions d?ajout sont utilisées dès que le nom de la partie correspondante est détecté, ainsi, le curseur de l?écriture du fichier est déjà au niveau des informations à traiter. Seuls les algorithmes des fonctions main\_create\_db, ajout\_arc , create\_index présentent un réel intérêt, comme les autres reprennent les mêmes principes, ils ne seront pas présentés.

\textit{Algorithme main\_create\_db :}
C?est lui qui ordonne l?exécution des différentes fonctions pour la création de l?espace réservé aux données et l?initialise.
\begin{verbatim}
Donnee * main_create_db(char * path){    char * line ;    Donnee * data;    /*allocation de la structure contenent toutes les donnees et initialisation*/    data = (Donnee *)malloc(sizeof(Donnee));    data->parametres.temps_execution = 0;    data->parametres.nb_arcs = 0;    data->lieux = NULL;    data->index_lieu = NULL;    data->map = NULL;    data->liste_lieu = NULL;    init_solution(data);    init_resultat(data);    /*ouvreture du fichier*/    FILE * file = open_file(data, path);    /*parcour de tous le fichier*/    while(!feof(file)){        /*lit les gigne une a une*/        line = readLine(file);        /*si la ligne commance par un # on utilise la fonction corespondane*/        if(line[0] == '#'){            if( strcasecmp(line + 1, "Parametres\n") == 0 ) ajout_parametre(data, file);            else if( strcasecmp(line + 1, "Lieux\n") == 0 ) ajout_lieux(data, file);                else if( strcasecmp(line + 1, "Arcs\n") == 0 ) ajout_arcs(data, file);                    else fatalerreur(data, "main_creat_db : aucun traitement pour cette ligne\n");        }        free(line);    }    create_liste(data);    create_index(data);    /*fermeture du fichier*/    fclose(file);    return data;
}
\end{varbatim}

\textit{Algorithme main\_create\_db :}
Son fonctionnement est intéressant, car c?est lui qui dispatche les chemins du fichier dans la table "map". Comme il l?inscrit aussi bien pour le lieu de départ que pour le lieu d?arrivée, il transforme les chemins en des arcs. Ce qui facilite leur utilisation future.\\Comme le nombre d?arcs entre chaque lieu est variable, et que l?allocation est une opération couteuse, car elle est susceptible d?engendrer un déplacement  de zone mémoire déjà existante, nous avons décidé de ne pas allouer l?espace pour les arcs un par un, mais pour une certaine quantité à chaque fois. Ce choix est basé sur l?idée que quitte à déplacer de la mémoire, autant le faire le moins possible. Cette quantité est le rapport entre le nombre d?arcs total est le nombre de lieu, car on suppose qu?en moyenne, il y a autant d?arcs pour chaque destination. Afin de pouvoir gère le nombre d?emplacements d?arc disponibles, on a créé le tableau temporaire "nb\_element\_lieu", ainsi, si le nombre d?arcs, pour un lieu donné, atteint la valeur contenue dans "nb\_element\_lieu", on alloue de nouveau de l?espace mémoire.\\
\begin{verbatim}

static void ajout_arcs(Donnee * data, FILE * file){    int nb_element = data->parametres.nb_arcs / data->parametres.nb_lieux + 1;    Arc **ch_tmp;    int i = 0, l1, l2, distance, insecurite;    int * nb_element_lieu;    /* allocation du tableau map a deux dimantions. cette table grandi en fonction de nb_element et du nombre d'arcs pour un lieu*/    data->map = (Arc ***)malloc(data->parametres.nb_lieux*sizeof(Arc**));    if(data->map == NULL) fatalerreur(data, "ajout_arcs : echec de l'allocation de map lv1");    for(i = 0;  i < data->parametres.nb_lieux; ++i){        data->map[i] = (Arc**)malloc(nb_element*sizeof(Arc*));        if(data->map[i] == NULL) fatalerreur(data, "ajout_arcs : echec de l'allocation de map lv2");    }    /* allocation d'un tableau temporaire servent a gere l'alloaction du nombre d'arcs de chaque lieu.*/    nb_element_lieu = (int *)malloc((data->parametres.nb_lieux)*sizeof(int));    if(nb_element_lieu == NULL) fatalerreur(data, "ajout_arcs : echec de l'allocation de nb_element_lieu");    /* initialisation de cette table a deux dimantions (nombre d'element x nombre d'element max)*/    for(i = 0; i < data->parametres.nb_lieux; ++i)        nb_element_lieu[i] = 0;    /* lecture du fichier ligne a ligne et traitement des informations*/    while(fscanf(file, "%d;%d;%d;%d\n", &l1, &l2, &distance, &insecurite) == 4){        /*si le nombre d'arcs enregistre est superieur ou egale au nombre d'element disponible, on augmante le nombre delements de nb_element*/        if(data->lieux[l1].nb_arc >= nb_element_lieu[l1]){            ch_tmp = (Arc**)realloc(data->map[l1], (nb_element + nb_element_lieu[l1])*sizeof(Arc*));            if(ch_tmp == NULL) fatalerreur(data, "ajout_arcs : echec de l'allocation de map lv2");            data->map[l1] = ch_tmp;            nb_element_lieu[l1] += nb_element; /*gaumentation du nombre d'elements possible*/        }        data->map[l1][data->lieux[l1].nb_arc] = (Arc *)malloc(sizeof(Arc));        if(data->map[l1][data->lieux[l1].nb_arc] == NULL) fatalerreur(data, "ajout_arcs : allocation de l'arc");        /* on instrit l'arc a son lieu de depart*/        data->map[l1][data->lieux[l1].nb_arc]->depart = &data->lieux[l1];        data->map[l1][data->lieux[l1].nb_arc]->insecurite = insecurite;        data->map[l1][data->lieux[l1].nb_arc]->distance = distance;        data->map[l1][data->lieux[l1].nb_arc]->destination = &data->lieux[l2];        data->lieux[l1].nb_arc++; /*gaumentation du nombre d'arcs enregirte*/        /*si le nombre d'arcs enregistre est superieur ou egale au nombre d'element disponible, on augmante le nombre delements de nb_element*/        if(data->lieux[l2].nb_arc >= nb_element_lieu[l2]){            ch_tmp = (Arc**)realloc(data->map[l2], (nb_element + nb_element_lieu[l2])*sizeof(Arc*));            if(ch_tmp == NULL) fatalerreur(data, "ajout_arcs : echec de l'allocation de map lv2");            data->map[l2] = ch_tmp;            nb_element_lieu[l2] += nb_element; /*gaumentation du nombre d'elements possible*/        }        data->map[l2][data->lieux[l2].nb_arc] = (Arc *)malloc(sizeof(Arc));        if(data->map[l2][data->lieux[l2].nb_arc] == NULL) fatalerreur(data, "ajout_arcs : allocation de l'arc");        /*on instrit l'arc a son lieu de d'arrive*/        data->map[l2][data->lieux[l2].nb_arc]->depart = &data->lieux[l2];        data->map[l2][data->lieux[l2].nb_arc]->insecurite = insecurite;        data->map[l2][data->lieux[l2].nb_arc]->distance = distance;        data->map[l2][data->lieux[l2].nb_arc]->destination = &data->lieux[l1];        data->lieux[l2].nb_arc++; /*gaumentation du nombre d'arcs enregirte*/    }    free(nb_element_lieu);    /*suppression des arc dommine et mise a jour de la table lieux en fonction*/    for( i = 0; i < data->parametres.nb_lieux; ++i){        qsort(data->map[i], data->lieux[i].nb_arc, sizeof(Arc*), position_arc);        data->lieux[i].nb_arc = epure_map(data, i);    }}
\end{verbatim}

\textit{Algorithme create\_index :}
Son rôle est de faciliter l?utilisation de la table  "map" en indiquant où commencent les arcs ayant les mêmes lieux de départ et de destination et le nombre d'arcs correspondant. Pour cela, elle parcourt toute la table "map" est à chaque changement de destination, elle alloue de la mémoire de type "index\_arc" est enregistre le numéro de la case où début la série d?arcs et le nombre qu?il y en a. s?il n?y a pas d?arc entre deux lieux, aucune allocation n?est faite, et le pointeur reste à NIL.\\
\begin{verbatim}

static void create_index(Donnee *data){    int id_lieu,i, last_lieu;    Arc **map;    /*creation de l'index de niveau 1*/    data->index_lieu = (Index_arc***)malloc(data->parametres.nb_lieux * sizeof(Index_arc**));    if(data->index_lieu == NULL)        fatalerreur(data, "create_index : creation de la table d'index impossible lv 1");    for( id_lieu = 0; id_lieu < data->parametres.nb_lieux; ++id_lieu){        map = data->map[id_lieu];        /*creation de l'index de niveau 1*/        data->index_lieu[id_lieu] = (Index_arc**)malloc(data->parametres.nb_lieux * sizeof(Index_arc*));        if(data->index_lieu[id_lieu] == NULL)            fatalerreur(data, "create_index : creation de la table d'index impossible lv 2");        /*initialisation a NULL*/        for(i = 0; i < data->parametres.nb_lieux; ++i)            data->index_lieu[id_lieu][i] = NULL;        /*creation de la structure Index_arc en fonction de map*/        data->index_lieu[id_lieu][map[0]->destination->id] = (Index_arc*)malloc(sizeof(Index_arc));        data->index_lieu[id_lieu][map[0]->destination->id]->id_arc = 0;        /*creation de la structure Index_arc en fonction de map pour les destination suivente*/        last_lieu = 0;        for(i = 1; i < data->lieux[id_lieu].nb_arc; ++i){            if(map[last_lieu]->destination != map[i]->destination){                data->index_lieu[id_lieu][map[i]->destination->id] = (Index_arc*)malloc(sizeof(Index_arc));                data->index_lieu[id_lieu][map[i]->destination->id]->id_arc = i;                data->index_lieu[id_lieu][map[last_lieu]->destination->id]->nb_arc = i - last_lieu;                last_lieu = i;            }        }        /*mise a jour du nombre d'arc disponible dans l'index*/        data->index_lieu[id_lieu][map[last_lieu]->destination->id]->nb_arc = i - last_lieu;    }}

\end{verbatim}

\chapter{Tris et suppression des arcs dominés}

\section{But de la suppression et du tri}

Dans les arcs renseignés par l'utilisateur rien n'indique qu'ils soient non dominés entre eux. Un arc dominé est, selon le critère de recherche, forcement mauvais. Par exemple, l'arc d'intérêt 6,  de distance 5 et d'insécurité 3 et dominé par un arc don les valeurs sont respectivement 7,5,3. Dans ce cas, bien qu'il y ai une distance et une insécurité identique, le deuxième arc l'emporte, car il possède un intérêt plus fort.\\

Il est donc nécessaire de supprimer, avant le début de la recherche, tous ces arcs qui sont ignorés dans la solution finale, mais qui feraient perdre du temps.\\

La relation de dominance entre les arcs ne peut s'établir que s'ils ont la même destination et la même source. Comme le tableau "map" qui détient l'ensemble des arcs est dans un premier temps rempli dans l'ordre où le fichier de donnée a été écrit, rien ne garantis que les arcs homologues se suivent.\\

Afin de simplifier l'algorithme de suppression des arcs dominés, il est donc nécessaire de trier la table "map" afin de regrouper les destinations entre elles. La structure de ce tableau ayant déjà effectué un regroupant des arcs en fonction du lieu de départ.\\

De même, comme on le verra dans la partie XX, la création du chemin de référence nécessite de connaitre l'arc de distance la plus courte entre deux points donnés. Le fait de trier les arcs en fonction de leur distance puis de leur insécurité en cas d'égalité, permet d'avoir en sommet de liste l'arc de distance minimal, ce qui évite de faire une recherche a chaque ajout d'un arc au chemin de base.
\\
Il est donc intéressant de trier cette table d'arcs, et ce en fonction de plusieurs critères :\\
\begin{itemize}
\item les arcs possédant une destination identique doivent être regroupés. Comme on cherche à maximiser l'intérêt du Parcours, les intérêts les plus forts sont placés au début. Si deux lieux on un intérêt identique, la destination possédant l'identifiant le plus faible est placé avant. 
\item Dans chaque groupe, les arcs sont triés a fin de minimiser la distance puis l'insécurité des premiers arcs.
\end{itemize}

\section{Algorithme de tris multi-critère}

L'algorithme de tris utilisé est celui du "Quicksort", bien que récursif, il permet d'avoir une complexité en $\Theta(n\log(n))$ dans le cas moyen. C'est à dire quand le pivot n'est pas sur une des extrémités du tableau à trier.\\
Comme les données sont rentrées manuellement, rien ne permet de près-dire où le pivot à des chances de ce trouver. On aurait pu choisir un pivot aléatoirement, mais nous avons décidé de le prendre au milieu de la table à trier.\\
Pour ce tri il y a plusieurs éléments à prendre en compte afin de décider si un élément doit se trouver avant ou après le pivot, les testes sont effectués par une fonction externe à celle de tris.\\

\textit{Algorithme de tri :}\\
Il s'agit une implémentation standard du « Quicksort », deux boucles positionnent les éléments dans un tableau qui est ensuite partagé en deux pour subir le même algorithme.

\algsetup{indent=3em}
\begin{algorithm}
\caption{Quicksort\_map}
\label{Quicksort_map}
\begin{algorithmic}[1]
\REQUIRE  ~\\
Entrée : \begin{itemize}
\item data pointeur sur la structure Donner\\
\item id\_Lieu entier, identifiant du lieu a trier\\
\item $m$ entier borne droit du tri\\
\item	$n$ entier  borne gauche du tri\\
\end{itemize}
Toutes les données sont valides
\ENSURE ~\\
Sortie : $\emptyset$ \\
Postcondition : data  $\to$ map[id\_lieu] est trier par : \begin{itemize}
\item Intérêt décroissant
\item Distance croissant
\item Insécurité croissant
\end{itemize}
\STATE $Arc **map \gets data->map[id_lieu];$
\STATE $int i, j, k;$
\IF {$(m<n)$}
   \STATE /*determination et sauvgarde du pivot*/
   \STATE $k$ $\gets$ $($m$+$n$)/2$
   \STATE swap (map[m],map[k])
   \STATE /*placement des marqueurs*/
   \STATE $i$ $\gets$ $m+1$
   \STATE $j$ $\gets$ $n$
   \STATE /*recherche des elements a permuter*/
   \WHILE {$i \leq j$}    
        \STATE /*element a gauche*/ 
        \WHILE {$((i \leq n)$ \& $position(data, id\_lieu,i,m)$}
	  \STATE $i \gets i+1$
        \ENDWHILE
        \STATE /*element a droit*/
        \WHILE {$((j \leq n)$ \& $position(data,id\_lieu,j,m)$}
            \STATE $j \gets j+1$
        \ENDWHILE
        \IF {$(i < j)$}
        	\STATE /*permutation*/
          \STATE swap (map[i],map[j])
        \ENDIF
   \ENDWHILE     
        \STATE  /* remise en place du pivot*/
        \STATE swap(map[m],map[j])
        \STATE /* appel récursif sur les deux demi-éléments droit et gauche*/
        \STATE quicksort\_map(data,id\_lieu,m,j-1)
        \STATE quicksort\_map(data,id\_lieu,j+1,n)
\ENDIF
\end{algorithmic}
\end{algorithm}

\newpage
\textit{Algorithme de la fonction position :}\\
Son rôle est d'indiquer si un arc se trouve avant ou après un autre. Le second arc, celui de référence, est nommé clef.
	Cette fonction prend en compte l'intérêt, la distance, la destination et l'insécurité. Si l'arc doit se trouver avant celui pointé par la clef, la fonction renvoie 0. Ce cas est vrai si :\\
\begin{enumerate}
\item L'intérêt de l'arc est supérieur à celui de la clef.
\item En cas d'égalité de l'intérêt, et de différence entre les identifiants des destinations, il faut que le numéro de destination de l'arc soit inférieur à celui de la clef.
\item En cas d'égalité de l'intérêt, il faut que la distance de l'arc soit inférieure à celui de la clef.
\item En cas d'égalité de l'intérêt et de la distance, il faut que l'insécurité de l'arc soit inférieure ou égale à celui de la clef.
\end{enumerate}

Pour s'affranchir de changement éventuel dans la structure de donnée, de  nombreuses fonctions ont été écrites afin de récupérer des valeurs précises. Cela présente également l'avantage de clarifier les algorithmes.

\algsetup{indent=3em}
\begin{algorithm}
\caption{Position}
\label{Position}
\begin{algorithmic}[1]
\REQUIRE  ~\\
Entrée : \begin{itemize}
\item data pointeur sur la structure donnée\\
\item id\_lieu entier, identifiant du lieu a trier\\
\item id\_arc entier, identifiant de l'arc\\
\item	id\_key entier, identifiant de la clef\\
\end{itemize}
Toutes les données doivent être valides
\ENSURE ~\\
Sortie : posi est un booléen \\
\begin{itemize}
\item posi = 0 : id\_arc avant id\_key
\item posi = 1 : id\_arc après id\_key
\end{itemize}
\STATE /*Initialisation : récuperation des valeurs*/
\STATE key\_interet $\gets$ interet\_map\_destination (data, id\_lieu, id\_key); 
\STATE key\_distance $\gets$ distance\_map\_arc (data, id\_lieu, id\_key);
\STATE key\_insecurite $\gets$ insecurite\_map\_arc (data, id\_lieu, id\_key);
\STATE key\_destination $\gets$ destination\_map\_arc (data, id\_lieu, id\_key);
\STATE arc\_interet $\gets$ interet\_map\_destination (data, id\_lieu, id\_arc);
\STATE arc\_distance $\gets$ distance\_map\_arc (data, id\_lieu, id\_arc); 
\STATE arc\_insecurite $\gets$ insecurite\_map\_arc (data, id\_lieu, id\_arc);
\STATE arc\_destination $\gets$ destination\_map\_arc (data, id\_lieu, id\_arc); 
\STATE /*comparaison*/
\IF {$(arc\_interet > key\_interet)$}
	\STATE Retourner ($posi=0$);
\ENDIF
\IF {$(arc\_interet = key\_interet)$}
	\IF {$(arc\_destination < key\_destination)$}
		\STATE Retourner ($posi = 0$);
	\ENDIF
	\IF {$(arc\_distance < key\_distance)$}
	\STATE Retourner ($posi = 0$);
	\ENDIF
	\IF {$(arc\_distance = key\_distance)$}
		\IF {$(arc\_insecurite \le key\_insecurite)$}
			\STATE Retourner ($posi = 0$);
		\ENDIF	
	\ENDIF
\ENDIF
\STATE Retourner($posi=1$)		
\end{algorithmic}
\end{algorithm}


\newpage
\section{Algorithme de suppression des arcs dominés}
Le rôle de cet algorithme de comparer tous les arcs entre eux afin de supprimer les dominés et les identiques. Un arc A est dominé pour un arc B si :\\
\begin{itemize}
\item Sa distance est supérieure ou égale à celle de B
\item Son insécurité est supérieure ou égale à celle de B\\
\end{itemize}

Cette Algorithme possède deux curseurs de lecture. Un premier qui sert de référence, et un deuxième qui sert de test. Le teste se déplace d'arc en arc jusqu'à ce que le lieu de destination entre teste et référence diffère. Lorsque c'est le cas, la référence ce décale d'un arc et le teste devient égale à la position de référence plus un. Ainsi, on ne compare que des arcs homologues ; ils sont tous testés et la fonction s'arrête quand la référence a atteint la fin du tableau.\\

Comme la suppression d'arc engendre des trous, nous avons du mètre en place un mécanisme qui décale le curseur de teste ou de référence s'ils viennent à designer un arc inexistant. Cette méthode est accompagnée d'une technique de copie qui déplace les arcs testés dès qu'un trou apparait. Pour ce fait il existe nu curseur nommé  "id\_cpy" qui indique la position vide.\\

%\algsetup{indent=3em}
%\begin{algorithm}
%\caption{Epure\_Map}
%\label{Epure\_Map}
%\begin{algorithmic}[1]
%\REQUIRE ~\\
%Entrée : \begin{itemize}
%\item data pointeur sur la structure donnée\\
%\item id\_lieu entier, identifiant du lieu a trier\\
%\end{itemize}
%\ENSURE ~\\
%\STATE /* Récuperation des valeurs de la clef*/
%\STATE int key_distance $/gets$ distance_map_arc(data, id_lieu, id_key);
%\STATE int key_insecurite $/gets$  insecurite_map_arc(data, id_lieu, id_key);
%\STATE int key_destination $/gets$  destination_map_arc(data, id_lieu, id_key);
%\STATE /*lecture de tous le tableau*/
%\FOR{$id\_arc$ {\textbf du} 1\ier{}arc \textbf{au} nbre\_arc}
% \STATE /*si l'arc n'existe pas, on prends le suivnat*/
%\end{algorithmic}
%\end{algorithm}

\textit {Algorithme d'épuration :}
\begin{verbatim}
int epure_map(Donnee *data,int id_lieu){
    int nbre_arc = nb_arc(data, id_lieu);
    int id_arc, id_key = 0, id_cpy = 1;

    int arc_distance, arc_insecurite, arc_destination;

    /*récupération des valeurs de la clef*/
    int key_distance = distance_map_arc(data, id_lieu, id_key);
    int key_insecurite = insecurite_map_arc(data, id_lieu, id_key);
    int key_destination = destination_map_arc(data, id_lieu, id_key);

    /*lecture de tous le tableau*/
    for(id_arc = 1 ; id_arc < nbre_arc ; ++id_arc){
        /*si l'arc n'existe pas, on prends le suivant*/
        while((id_arc != nbre_arc)&&(existe_map_arc(data, id_lieu, id_arc) == 0)) id_arc++;

        /*récupération des valeurs de l'arc*/
        arc_distance = distance_map_arc(data, id_lieu, id_arc);
        arc_insecurite = insecurite_map_arc(data, id_lieu, id_arc);
        arc_destination = destination_map_arc(data, id_lieu, id_arc);

        /*si l'arc est dominé, on le supprime*/
        /*à destination égale, les intérêt sont égaux*/
        if((arc_destination == key_destination)&&(arc_distance >= key_distance)&&(arc_insecurite >= key_insecurite)){
            spr_str_map_arc(data, id_lieu, id_arc);
            maj_str_map_arc(data, id_lieu, id_arc, NULL);
        }
        else{
            /*si les lieux de destination sont différant*/
            if(arc_destination != key_destination){
                /*on déplace la clef d'un*/
                ++id_key;
                /*si l'arc n'existe pas, on prends le suivant*/
                while((id_key != nbre_arc)&&(str_map_arc(data, id_lieu, id_key) == NULL)) ++id_key;

                /*récupération des valeurs de la clef*/
                key_distance = distance_map_arc(data, id_lieu, id_key);
                key_insecurite = insecurite_map_arc(data, id_lieu, id_key);
                key_destination = destination_map_arc(data, id_lieu, id_key);
            }

            /* s'il y a des arcs de supprimes, on comble les trous*/
            if(id_arc != id_cpy){
                if(str_map_arc(data, id_lieu, id_cpy) != NULL) spr_str_map_arc(data, id_lieu, id_cpy);
                maj_str_map_arc(data, id_lieu, id_cpy, str_map_arc(data, id_lieu, id_arc));
                maj_str_map_arc(data, id_lieu, id_arc, NULL);
            }
            ++id_cpy;
        }
    }
    return id_cpy;
}
\end{verbatim} 

\section{Utilisation des solutions}
La table solution est utilisée pour stocker le chemin de référence et ceux qui sont en attente pour générer l?ensemble des solutions qu?ils renfermement. Comme ces résultats partiel son issues du chemin de base, Il est nécessaire de définir des méthodes pour pouvoir créer, copier, modifier et supprimer une solution afin que les algorithmes de recherche puissent opérer.\\

Attention, comme pour toutes les fonctions définit pour ce projet, il n?y a aucuns teste pour savoir si l?opération est permise ou non. C?est à l?utilisateur de savoir ce qu?il fait et ce qu?il désir.\\

\subsection{Les méthodes de création et de suppression de solutions}

La fonction all\_solutions, est conçue pour créer et initialiser un certain nombre de nouvelles solutions, voir, si la table n?existe pas, c?est elle qui la créer. Ces nouveaux espaces sont obligatoirement ajoutés à la fin de la table. La structure de donnée et le nombre de solutions que l?on désire créer sont passés en paramètre.\\

Après son utilisation on dispose du nombre de solutions désiré. Le nombre de solutions allouées est défini dans la structure « solutions», cette fonction maintien cette valeur à jour. Toutes caractéristiques sont initialisées à zéro et les tables itinéraire, trajet et visite à NIL.\\

\textit {Algorithme de all\_solutions :}
\begin{verbatim}

void all_solutions(Donnee *data, int nb_ajout){
    int nb_solution_totale = nb_solution(data);
    int nb_reallocation = nb_solution_totale + nb_ajout;
    int i;
    Parcours **temp_doublep;

    /*on redimentionne la table du nombre specifie*/
    temp_doublep = (Parcours **)realloc(data->solution.solution, nb_reallocation*sizeof(Parcours*));
    if(temp_doublep == NULL) fatalerreur(data, "all_solutions : echeque de l'allocation");
    data->solution.solution = temp_doublep;

    /*definition des nouvelles tables*/
    for(i = data->solution.nb_solution; i < nb_reallocation; ++i){
        /*creation de la solution*/
        data->solution.solution[i] = (Parcours *)malloc(sizeof(Parcours));
        if(data->solution.solution[i] == NULL) fatalerreur(data, "all_solutions : echeque de l'allocation de all_solutions");

        /*initialisation des caracteristique*/
        data->solution.solution[i]->carac.distance = 0;
        data->solution.solution[i]->carac.insecurite = 0;
        data->solution.solution[i]->carac.interet = 0;
        data->solution.solution[i]->carac.nb_lieux_total = 0;
        data->solution.solution[i]->carac.nb_lieux_utile = 0;
        data->solution.solution[i]->carac.nb_arc = 0;

        data->solution.solution[i]->itineraire = NULL;
        data->solution.solution[i]->trajet = NULL;
        data->solution.solution[i]->visite = NULL;
    }

    /* mise a jour du nombre de solution*/
    data->solution.nb_solution = nb_reallocation;
}
\end{verbatim}

Pour supprimer des solutions, il existe plusieurs méthodes : 
\begin{itemize}
\item unall\_nb\_solutions : elle est équivalente à all\_solutions ; en plus de la supprimer, elle réadapte la taille du tableau "solutions". Les solutions qu?elles suppriment sont donc nécessairement à la fin de cette table. Elle maintint à jour le nombre de solutions présent, mais ne désalloue pas totalement la table "solutions" même si elle devient vide.
\item unall\_table\_solution : vide entièrement la table est la supprime de la mémoire.
\item unall\_solution : supprime une solution au milieu de la table, la case du tableau "solutions" sensé contenir l?adresse de la solution supprimée obtiens la valeur NIL.
\end{itemize}

Pour désallouer correctement la mémoire, il est nécessaire de préalablement supprimer les tableaux "trajectoire", "itinéraire" et "visite" qui sont contenus dans la solution. Cependant, visite n?existe pas forcement, c?est pour quoi il est nécessaire de tester sont existence. Si cette table n?existe pas, alors le pointeur "visite" présent dans la structure "solutions" est à NIL.\\

\textit {Algorithme de unall\_solutions :}
\begin{verbatim}
void unall_solution(Donnee *data, int id_solution){

    free(data->solution.solution[id_solution]->itineraire);
    free(data->solution.solution[id_solution]->trajet);

    if(data->solution.solution[id_solution]->visite != NULL){

        free(data->solution.solution[id_solution]->visite);
        data->solution.solution[id_solution]->visite = NULL;
    }

    free(data->solution.solution[id_solution]);

    data->solution.solution[id_solution] = NULL;
}
\end{verbatim}



\textit{Algorithme unall\_nb\_solutions :} 
\begin{verbatim}
void unall_nb_solutions(Donnee *data, int nb_suppretion){
    int nb_solution_totale = nb_solution(data);
    int nb_solution_restant = nb_solution_totale - nb_suppretion;
    int i;
    Parcours **temp_doublep;

    for(i = nb_solution_restant; i < nb_solution_totale; ++i){
        unall_solution(data, i);
    }

    temp_doublep = (Parcours **)realloc(data->solution.solution, nb_solution_restant*sizeof(Parcours*));
    if(temp_doublep == NULL) fatalerreur(data, "unall_table_solutions : echeque de la reallocation");
    data->solution.solution = temp_doublep;

    data->solution.nb_solution = nb_solution_restant;
}
\end{verbatim}

%\algsetup{indent=3em}
%\begin{algorithm}
%\caption{}
%\label{}
%\begin{algorithmic}[1]
%\REQUIRE ~\\
%Entré:\\
%\begin{itemize}
%\item data pointeur sur la structure donnée\\
%\item nb\_suppression un entier\\
%\end{itemize} 
%\ENSURE ~\\
%\STATE /*Initialisation*/
%\STATE int nb\_solution\_totale $\gets$ nb\_solution(data);
%\STATE int nb\_solution\_restant $\gets$ nb\_solution\_totale - nb\_suppretion;
%\STATE int i;
%\STATE Parcours **temp\_doublep;
%	\FOR{$i$ {\textbf du} nb\_solution\_restant; i < nb\_solution\_totale; ++i}
%	%	\FOR{$i$ {\textbf du} 1\ier{}lieu \textbf{au} dernier lieu}
%		\STATE unall\_solution(data, i);
%	\ENDFOR	
%	\STATE temp\_doublep $\gets$ (Parcours **)realloc(data$\to$solution.solution, nb\_solution\_restant*sizeof(Parcours*));
%	\IF {(temp\_doublep = NULL) }
%	\STATE fatalerreur(data, "unall\_table\_solutions : echeque de la reallocation");
%	\ENDIF
%	\STATE data$to$solution.solution $\gets$ temp\_doublep;
%	\STATE data$to$solution.nb\_solution $\gets$ nb\_solution\_restant;
%\end{algorithmic}
%\end{algorithm}



\textit{Algorithme unall\_table\_solution :}
\begin{verbatim}
void unall_table_solutions(Donnee *data){
    int i;

    for(i = 0; i < data->solution.nb_solution; ++i){
        unall_solution(data, i);
    }
    free(data->solution.solution);
}
\end{verbatim}

\subsection{La méthode pour copier une solution}
Comme une solution est la modification du chemin de référence, il est plus commode de copier ce dernier avant toutes modifications. L?existence de cette fonction de copie présente l?avantage de préserver le chemin de base et de ne pas avoir à la régénérer pour pouvoir le modifier.\\

La fonction cpy\_solution, recopie un à un tous les éléments de la source vers la destination. Les caractéristiques sont dupliquées et les tables "trajet" et "itineraire" sont créés et affecté avec les valeurs correspondantes, seules la table "visite" est ignorée, car la probabilité pour qu?elle soit utile sur ce chemin est presque nulle. Si cela est nécessaire, la fonction générant le chemin de base, seule fonction utilisatrice de cette table, est capable de la recréer. Faire cette omission présente l?avantage de limiter l?utilisation superflue de la mémoire, de minimiser les instructions de copie pour un risque quasi inexistant.

\textit{Algorithme cpy\_solution :}
\begin{verbatim}
void cpy_solution(Donnee *data, int id_solution_destination, int id_solution_source){
    int i, nb_lieux_total;
    Arc **temp_arc;
    Lieu **temp_lieu;
    Parcours *destination_solution = data->solution.solution[id_solution_destination];
    Parcours *source_solution = data->solution.solution[id_solution_source];

    /*copie des caracteristiques*/
    destination_solution->carac.distance = source_solution->carac.distance;
    destination_solution->carac.insecurite = source_solution->carac.insecurite;
    destination_solution->carac.interet = source_solution->carac.interet;
    destination_solution->carac.nb_arc = source_solution->carac.nb_arc;
    destination_solution->carac.nb_lieux_total = source_solution->carac.nb_lieux_total;
    destination_solution->carac.nb_lieux_utile = source_solution->carac.nb_lieux_utile;

    /*copie de l'itineraire*/
    nb_lieux_total = destination_solution->carac.nb_lieux_total;

    /*on augmente l'itineraire de nb_lieux_total*/
    temp_lieu = (Lieu **)realloc(destination_solution->itineraire, (nb_lieux_total)*sizeof(Lieu *));
    if(temp_lieu == NULL) fatalerreur(data, "cpy_solution : echeque de la realocation de itineraire");
    destination_solution->itineraire = temp_lieu;

    for(i = 0; i < nb_lieux_total; ++i){
        destination_solution->itineraire[i] = source_solution->itineraire[i];
    }

    /*copy du trajet*/
    /*on augmante le trajet de nb_lieux_total*/
    temp_arc = (Arc **)realloc(destination_solution->trajet, (nb_lieux_total -1)*sizeof(Arc *)); //-1 : il y a un arc de moins que de lieu
    if(temp_arc == NULL) fatalerreur(data, "cpy_solution : echeque de la realocation de trajet");
    destination_solution->trajet = temp_arc;

    /*on affecte l'adresse de l'arc*/
    for(i = 0; i < nb_lieux_total -1; ++i){
        destination_solution->trajet[i] = source_solution->trajet[i];
    }

    /*on ne copy pas la table des visites car elle n'est utilisé que pour la generation de chemin de referance*/
}
\end{verbatim}

\subsection{Les méthodes pour modifier une solution}

La modification d?une solution ne comprend pas uniquement la simple possibilité de modifier des valeurs contenues dans les caractéristiques ou un lieu ou un arc. Il faut aussi pouvoir rajouter des éléments à la solution ciblée. 
C?est pour cela que de nombreuses de fonctions modification ont été créées :
\begin{itemize}
\item add\_arc\_solution : ajout un arc à la fin de la solution
\item add\_lieu\_solution : ajout un lieu à la fin de la solution
\item maj\_lieu\_total\_soltuion : affecte un nouveau nombre de lieux total
\item maj\_nb\_lieu\_utile\_solution : affecte un nouveau nombre de lieux utiles
\item maj\_distance\_solution : change la distance de la solution
\item maj\_insecurite\_solution : change l?insécurité de la solution
\item maj\_interet\_solution : change l?intérêt de la solution
\item maj\_arc\_solution : change l?arc désigné dans la table trajet
\item maj\_lieu\_solution : change le lieu désigné dans la table trajet
\end{itemize}

Seuls les algorithmes de add\_arc\_solution et add\_lieu\_solution sont présentés, les autres fonctions sont de simples modifications de valeurs dans une structure et ne présente que peu d?intérêt.

\begin{verbatim}
void add_lieu_solution(Donnee *data, int id_solution, int id_lieu){
    int nb_lieu = data->solution.solution[id_solution]->carac.nb_lieux_total++;
    Lieu **temp;

    /*on augmente l'itineraire de 1*/
    temp = (Lieu **)realloc(data->solution.solution[id_solution]->itineraire, (nb_lieu +1)*sizeof(Lieu *));
    if(temp == NULL) fatalerreur(data, "add_li; maj_lieu_totaleu_solution : echeque de la realocation");
    data->solution.solution[id_solution]->itineraire = temp;

    /*on affecte l'adresse du lieu*/
    data->solution.solution[id_solution]->itineraire[nb_lieu] = str_lieu(data, id_lieu);
}
\end{verbatim}


\begin{verbatim}
void add_arc_solution(Donnee *data, int id_solution, int id_lieu_depart, int id_lieu_arrive, int offset){
    int nb_arc = data->solution.solution[id_solution]->carac.nb_arc++;
    Arc **temp;
    int id_arc;
    Arc *arc;

    /*recupere la position du premier arc disponible a la quelle on ajout l'offset*/
    id_arc = index_id_arc(data, id_lieu_depart, id_lieu_arrive);
    arc = str_map_arc(data, id_lieu_depart, id_arc) + offset;

    /*on augmante le trajet de 1*/
    temp = (Arc **)realloc(data->solution.solution[id_solution]->trajet, (nb_arc +1)*sizeof(Arc *));
    if(temp == NULL) fatalerreur(data, "add_lieu_solution : echeque de la realocation");
    data->solution.solution[id_solution]->trajet = temp;

    /*on affecte l'adresse de l'arc*/
    data->solution.solution[id_solution]->trajet[nb_arc] = arc;
}
\end{verbatim}

Afin que l?utilisateur soit le moins dépendant possible de la forme des structures des données, nous avons créé des fonctions intermédiaires capables de récupérer la bonne valeur, le bon pointeur. En contrepartie, aucuns testes n?est effectué pour déterminer si l?action est permise ou non.
Parmi ces fonctions intermédiaires, se trouve :\\
\begin{itemize}
\item Distance\_arc\_solution : renvoie la distance d?un arc en fonction de son identifiant dans la table "trajet" et de celui de la solution,
\item Distance\_solution : renvoie la distance totale de la solution
\item Id\_depart\_trajet\_solution : renvoie l?identifiant du lieu de départ de l?arc désigné
\item Id\_destination\_trajet\_solution : renvoie l?identifiant du lieu de destination de l?arc désigné
\item Id\_laste\_lieu\_solution : renvoie l?identifiant du dernier lieu du chemin, utile pour connaitre le point d?arrivée
\item Id\_lieu\_solution : renvoie l?identifiant du lieu désigné
\item Insecurite\_arc\_solution : renvoie l?insécurité de l?arc désigné
\item distance\_arc\_solution : renvoie la distance de l?arc désigné
\item interet\_lieu\_solution : renvoie l?intérêt du lieu
\item intérêt\_solution : renvoie l?intérêt total de la solution
\item nb\_arc\_solution : renvoie le nombre d?arcs dans la solution
\item nb\_lieu\_solution : renvoie le nombre de lieu utile
\item nb\_lieu\_totale\_solution : renvoie le nombre de lieux total
\item nb\_solution : renvoie le nombre de solutions existantes dans la table
\end{itemize}

Cette liste non exhaustive présente les fonctions les plus utilisées, comme pour une grande partie d?entre elles, elles ne sont constituées que d?une seule ligne, nous ne présenterons pas leurs algorithmes.\\

Grace à ces fonctions nous disposons présent d?outils pour créer modifier et supprimer une solution. Cela nous serra très utile pour la réalisation du chemin de référence et des optimisations.\\

\section{Passage de la table des solutions à celle des résultats}
\subsection{Utilisation de l?espace mémoire}

Avant de commencer à transférer des données d?un tableau à un autre, il est nécessaire de réserver de l?espace mémoire pour les accueillir. C?est pour cela que la fonction all\_resultats a été créée. Tous comme son homologue all\_solutions, sont rôle est d?agrandir le tableau qui stockera les résultats. Elle possède cependant quelques nuances :
\begin{itemize}
\item contrairement à la structure "solutions" qui renferme la variable "nb\_solution" indiquant le nombre d?éléments du tableau, ici la structure "resultats" contient un tableau a deux dimensions nommée "nb\_resultats" (voir la partie consacrée à la structure "résultats" pour plus de détaille).
\item Elle est capable de désallouer les résultats lorsqu?on lui fournit un nombre d?allocations négatifs.  Mais elle ne supprime pas la table pour autant.
\item Elle met à jour à la fois le nombre de résultats alloués, mais aussi le nombre de résultats utilisés si nécessaire.
\end{itemize}

Bien que lors de la copie des solutions, la table "visite" n?est pas traitée, il se peut qu?elle soit présent suit a l?utilisation de la fonction couper/déplacée présenté plus loin dans ce chapitre. Il est donc toujours nécessaire de vérifier l?existence de "visite" lors de la désallocation. Cela est vrai pour all\_resultats et unall\_resultat.\\

\textit{Algorithme all\_resultats une fois implementé en C:}
\begin{verbatim}

void all_resultats(Donnee *data, int nb_lieux, int nb_ajout){

  int **tmp_doubptr_int;
  int i, nb_l;
  Parcours ***tmp_tripptr_Parcours;
  Parcours **tmp_doubptr_Parcours;
    
/*ajout de parcours*/

  if(data->resultat.nb_lieux < nb_lieux){ 
  /*reallocation de la table des Parcourss enxistant en fonction des leux*/
    tmp_doubptr_int = (int**)realloc(data->resultat.nb_resultats, nb_lieux*sizeof(int*));
    if(tmp_doubptr_int == NULL) 
      fatalerreur(data, "all_resultats : echeque de la reallocation de la table des resultats lv1");
    data->resultat.nb_resultats = tmp_doubptr_int;

    for(i = data->resultat.nb_lieux; i < nb_lieux; ++i){
      data->resultat.nb_resultats[i] = (int*)malloc(2*sizeof(int));
      if(data->resultat.nb_resultats[i] == NULL) 
        fatalerreur(data, "all_resultats : echeque de la reallocation de la table des resultats lv2");
      data->resultat.nb_resultats[i][0] = 0;
      data->resultat.nb_resultats[i][1] = 0;
        }

     /*realocation des parcours*/
      tmp_tripptr_Parcours = (Parcours ***)realloc(data->resultat.resultats, nb_lieux*sizeof(Parcours**));
      if(tmp_tripptr_Parcours == NULL) 
      	fatalerreur(data, "all_resultats : echeque de la reallocation des Parcourss lv1");
      data->resultat.resultats = tmp_tripptr_Parcours;
      
      for( i = data->resultat.nb_lieux; i < nb_lieux; ++i)
            data->resultat.resultats[i] = NULL;

        /* mise à jour du maximum de lieux utilise*/
        data->resultat.nb_lieux = nb_lieux;
    }


    if(nb_ajout > 0){

        /*allocation des nouveaux resultat*/
        nb_l = data->resultat.nb_resultats[nb_lieux -1][1] + nb_ajout;
        tmp_doubptr_Parcours = (Parcours **)realloc(data->resultat.resultats[nb_lieux -1], (nb_l)*sizeof(Parcours*));
        if(tmp_doubptr_Parcours == NULL) fatalerreur(data, "all_resultats : echec de la reallocation des parcours lv2");
        data->resultat.resultats[nb_lieux -1] = tmp_doubptr_Parcours;

        /*initialisation de la partie rajoute*/
        for(i = data->resultat.nb_resultats[nb_lieux -1][1]; i < data->resultat.nb_resultats[nb_lieux -1][1] + nb_ajout; ++i){
            /*creation des desultat*/
            data->resultat.resultats[nb_lieux -1][i] = (Parcours *)malloc(sizeof(Parcours));
            if(data->resultat.resultats[nb_lieux -1][i] == NULL) fatalerreur(data, "all_resultats : echec de l'allocation des resultats vl3");

            /*initialisation des caracteristique*/
            data->resultat.resultats[nb_lieux -1][i]->carac.distance = 0;
            data->resultat.resultats[nb_lieux -1][i]->carac.insecurite = 0;
            data->resultat.resultats[nb_lieux -1][i]->carac.interet = 0;
            data->resultat.resultats[nb_lieux -1][i]->carac.nb_lieux_total = 0;
            data->resultat.resultats[nb_lieux -1][i]->carac.nb_lieux_utile = 0;
            data->resultat.resultats[nb_lieux -1][i]->carac.nb_arc = 0;

            data->resultat.resultats[nb_lieux -1][i]->itineraire  = NULL;
            data->resultat.resultats[nb_lieux -1][i]->trajet = NULL;
            data->resultat.resultats[nb_lieux -1][i]->visite = NULL;
        }
    }
    else{
        for(i = data->resultat.nb_resultats[nb_lieux -1][1] + nb_ajout; i < data->resultat.nb_resultats[nb_lieux -1][1]; ++i){
            free(data->resultat.resultats[nb_lieux -1][i]->trajet);
            free(data->resultat.resultats[nb_lieux -1][i]->itineraire);

            if(data->resultat.resultats[nb_lieux -1][i]->visite != NULL)
                free(data->resultat.resultats[nb_lieux -1][i]->visite);

            free(data->resultat.resultats[nb_lieux -1][i]);
        }

        /*desallocation des resultat*/
        nb_l = data->resultat.nb_resultats[nb_lieux -1][1] + nb_ajout;
        tmp_doubptr_Parcours = (Parcours **)realloc(data->resultat.resultats[nb_lieux -1], (nb_l)*sizeof(Parcours*));
        if(tmp_doubptr_Parcours == NULL) fatalerreur(data, "all_resultats : echec de la reallocation des Parcourss lv2");
        data->resultat.resultats[nb_lieux -1] = tmp_doubptr_Parcours;
    }

    /*mise a jour du nombre de résultats en fonction du nombre de lieux*/
    if(data->resultat.nb_resultats[nb_lieux -1][1] + nb_ajout < data->resultat.nb_resultats[nb_lieux -1][0])
        data->resultat.nb_resultats[nb_lieux -1][0] = data->resultat.nb_resultats[nb_lieux -1][1] + nb_ajout;

    data->resultat.nb_resultats[nb_lieux -1][1] += nb_ajout;
}
\end{verbatim}
	
Il existe aussi une fonction nommée unall\_resultats qui est chargé d?effacer totalement le tableau "resultats" de la mémoire

\textit{Alogorithme Unall\_resultat :}

Pratiquement identique à unall\_solutions, il doit cependant travailler sur un tableau à trois dimensions, ce qui explique la présence d?une boucle supplémentaire.
Voici l'implémentation en C
\begin{verbatim}
void unall_resultats(Donnee *data){
    int i, j;

    for(i = 0; i < data->resultat.nb_lieux ; ++i){
        if(data->resultat.resultats[i] != NULL){
            for(j = 0; j < data->resultat.nb_resultats[i][1]; ++j){
                if(data->resultat.resultats[i][j] != NULL){
                    free(data->resultat.resultats[i][j]->itineraire);
                    free(data->resultat.resultats[i][j]->trajet);

	       if(data->resultat.resultats[i][j]->visite != NULL)
		free(data->resultat.resultats[i][j]->visite);
                }
                free(data->resultat.resultats[i][j]);
            }

            free(data->resultat.resultats[i]);
        }
    }
    free(data->resultat.resultats);

    for(i = 0; i < data->resultat.nb_lieux; ++i){
        free(data->resultat.nb_resultats[i]);
    }
    free(data->resultat.nb_resultats);
}
\end{verbatim}

\subsection{Copie de la solution vers les résultats}
Le chemin résultant de l?optimisation est un résultat en soit, est il doit être placé dans le tableau « résultats », pour cela nous avons créé deux fonctions :\\
\begin{itemize}
\item cpy\_solution\_to\_resultat : qui fonctionne de la même manière que cpy\_solutions.
\item cut\_solution\_to\_resultat : copie et retire l?adresse mémoire de la solution pour la placer dans les résultats. Elle présente l?avantage d?avoir une complexité nettement plus faible que cpy\_solution\_to\_resultat ce qui lui garantit un temps d?exécution plus faible. Mais comme elle retire le chemin des solutions, elle équivaut aussi à un dépilage. Ces deux raisons majeures nous permettent de n?utiliser que cut\_solution\_to\_resultat pour obtenir un phénomène de pille sur le tableau "solutions".\\
\end{itemize}
C?est deux fonctions place les éléments à copier à la fin du tableau "resultats" désigné par le nombre de lui que possède le chemin. C?est pour cela qu?il n?est pas nécessaire de préciser la position de destination. Par contre, l?utilisateur de la fonction peut avoir besoin de savoir à quelle position le chemin a été copier, c?est pour quoi, c?est fonction renvoie cette information.

\textit{Algorithme cpy\_solution\_to\_resultat :}
\begin{verbatim}
int cpy_solution_to_resultat(Donnee *data, int nb_lieux, int id_solution){
    int i, nb_lieux_total;
    Arc **temp_arc;
    Lieu **temp_lieu;
    Parcours *destination_resultat;
    Parcours *source_solution;
    int id_resultat;

    /*si la table de resultat n'existe pas encore, on la cree*/
    if(data->resultat.nb_lieux < nb_lieux)
        all_resultats(data, nb_lieux, 1);

    id_resultat = nb_resultats_use_by_lieu(data, nb_lieux);

    if(id_resultat >= nb_resultats_all_by_lieu(data, nb_lieux))
        all_resultats(data, nb_lieux, 1);

    destination_resultat = data->resultat.resultats[nb_lieux -1][id_resultat];
    source_solution = data->solution.solution[id_solution];

    /*copy des caracteristique*/
    destination_resultat->carac.distance = source_solution->carac.distance;
    destination_resultat->carac.insecurite = source_solution->carac.insecurite;
    destination_resultat->carac.interet = source_solution->carac.interet;
    destination_resultat->carac.nb_arc = source_solution->carac.nb_arc;
    destination_resultat->carac.nb_lieux_total = source_solution->carac.nb_lieux_total;
    destination_resultat->carac.nb_lieux_utile = source_solution->carac.nb_lieux_utile;

    /*copy de l'itineraire*/
    nb_lieux_total = destination_resultat->carac.nb_lieux_total;

    /*on augmente l'itineraire de nb_lieux_total*/
    temp_lieu = (Lieu **)realloc(destination_resultat->itineraire, (nb_lieux_total)*sizeof(Lieu *));
    if(temp_lieu == NULL) fatalerreur(data, "cpy_solution_to_resultat : echeque de la realocation de itineraire");
    destination_resultat->itineraire = temp_lieu;

    for(i = 0; i < nb_lieux_total; ++i){
        destination_resultat->itineraire[i] = source_solution->itineraire[i];
    }

    /*copy du trajet*/
    /*on augmante le trajet de nb_lieux_total*/
    temp_arc = (Arc **)realloc(destination_resultat->trajet, (nb_lieux_total -1)*sizeof(Arc *)); //-1 : il y a un arc de moins que de lieu
    if(temp_arc == NULL) fatalerreur(data, "cpy_solution_to_resultat : echeque de la realocation de trajet");
    destination_resultat->trajet = temp_arc;

    /*on affecte l'adresse de l'arc*/
    for(i = 0; i < nb_lieux_total -1; ++i){
        destination_resultat->trajet[i] = source_solution->trajet[i];
    }

    data->resultat.nb_resultats[nb_lieux -1][0]++; //augmante de 1 le nombre de resultat utilise
    /*on ne copy pas la table des visites car elle n'est utilisé que pour la generation de chemin de referance*/
    return id_resultat;// renvoi la position de la copie
}
\end{verbatim}

\textit{Algorithme cut\_solution\_to\_resultat :}
Contrairement à cpy\_solution\_to\_resultat, cut\_solution\_to\_resultat doit gère le vide occasionné par la suppression d?un élément du tableau. Il se charge aussi de la désallocation et de la suppression définitive de cette table quand il n?y a plus de solution dedans.\\
\begin{verbatim}
int cut_solution_to_resultat(Donnee *data, int nb_lieux, int id_solution){
    int id_resultat;
    Parcours **tmp;

    /*récupère le nombre de résultat utilisé. comme ils sont contenues dans un tableau (debut a 0), cela correspond aussi a la position du nouvel élément*/
    id_resultat = nb_resultats_use_by_lieu(data, nb_lieux);

    /*libere cette espace, en effet contrairement a copie, cette espace existe deja dans le tableau des solutions*/
    free(data->resultat.resultats[nb_lieux -1][id_resultat]);

    /*cpoie de l'adresse*/
    data->resultat.resultats[nb_lieux -1][id_resultat] = data->solution.solution[id_solution];

    /*increùmantation du nombre de resultats utilisé*/
    data->resultat.nb_resultats[nb_lieux -1][0]++;

    /*comble le vide engendre dans le tableau des solutions*/
    while(id_solution < data->solution.nb_solution -1){
        data->solution.solution[id_solution] = data->solution.solution[id_solution +1];
        id_solution++;
    }

    /*desaloue la derniere solution du tableaux, si le tableau est vide, il est suprimé*/
    if(data->solution.nb_solution == 1){
        data->solution.nb_solution = 0;

         free(data->solution.solution);
    }
    else{
        data->solution.nb_solution -= 1;
        //unall_solution(data, data->solution.nb_solution);

        tmp = (Parcours **)realloc(data->solution.solution, (data->solution.nb_solution)*sizeof(Parcours*));
        if(tmp == NULL) fatalerreur(data, "cut_solution_to_resultat : echeque de la reallocation");
        data->solution.solution = tmp;
    }

    /*renvoie la position de destination*/
    return id_resultat;
}
\end{verbatim}

\subsection{Enumeration des résultants}

La fonction genere\_resultats est prévue pour créer tous les résultants possibles en permutant les arcs du chemin qui vient juste d?être copiée. En effet, elle prend comme référence le dernier résultat de la table. Comme les algorithmes d?optimisation ne se basent que sur des villes, les arcs restent ceux du chemin de référence. Et comme il est construit en utilisant les arcs de plus petites distances on connaît déjà leur position dans la table  "map", il s?agit des arcs au début du tableau désigné par "index\_map".\\
Cette information est intéressante, car comme nous faisons un parcourt en largeur des arcs, cela évite d?avoir à gérer l?arc numéroté zéro dans le tableau.\\
Cependant, tous les chemins ne sont pas intéressants, si un résultat dominé est trouvé, il n?est pas enregistré. De même, si le trajet servent de graine devient dominé, il est remplacé. En précédant ainsi, le tableau des résultats contient des chemins de lus en plus acceptable. Mais cela n?empêche pas le tableau résultats de contenir des trajets non désirables, car un chemin non dominé à une énumération donnée peut le devenir à la suivante. Pourtant il à bien été enregistré. C?est pour cela que nous avons créé la fonction epure\_resultats, qui est comparable a epure\_map.\\ 
epure\_resultats à pour but de supprimer tous les chemins dominés ou identiques. Il travaille sur l?ensemble de la table "resultats" qui est désigné par son nombre de lieux. Ainsi, s?il y a eu plusieurs générations, on est sûrs que les potentiels doublons ont disparu tous comme les chemins dominés.

\textit{Implémentation en C de l'algorithme de genere\_resultats :}
\begin{verbatim}

void genere_resultats(Donnee *data, int nb_lieux){
    int id_resultat = data->resultat.nb_resultats[nb_lieux -1][0] -1;
    int nb_lieux_resultat = data->resultat.resultats[nb_lieux -1][id_resultat]->carac.nb_arc;
    int lieu, arc;
    Parcourt* table_resultat = data->resultat.resultats[nb_lieux -1][id_resultat];
    int id_destination, id_depart;
    int nb_arc_genere;
    int nb_resutats_vide;
    int id_write_resultat = id_resultat + 1;
    int distance_new, insecurite_new;
    int distance_ref, insecurite_ref;

    /*pour tous les lieux du chemin*/
    for(lieu = 0; lieu < nb_lieux_resultat; ++lieu){
        /* on recupere leur valeur*/
        id_depart = table_resultat->itineraire[lieu]->id;
        id_destination = table_resultat->itineraire[lieu + 1]->id;
        nb_arc_genere = index_nb_arc(data, id_depart, id_destination); //nombre d'arc entre le depart et la destination
        nb_resutats_vide =  data->resultat.nb_resultats[nb_lieux -1][1] - data->resultat.nb_resultats[nb_lieux -1][0]; //nombre d'arc alloué et non utilise

        if(nb_resutats_vide < nb_arc_genere){ //on alloue si le nombre de resultat disponible est inferieur aux nombre de resultat necessaire
            all_resultats(data, nb_lieux, data->resultat.nb_resultats[nb_lieux -1][1] + nb_arc_genere - nb_resutats_vide); //allocation du nombre de resultat necessaire
        }

        distance_ref = distance_totale_resultat(data, nb_lieux, id_resultat);
        insecurite_ref = insecurite_totale_resultat(data, nb_lieux, id_resultat);

        /*pour tous les arcs disponible entre le lieu de depart et le lieu d'arrive*/
        for(arc = 1; arc < nb_arc_genere; ++arc){
            distance_new = distance_ref - distance_arc_resultat(data, nb_lieux, id_resultat, lieu) + distance_arc(data, id_depart, id_destination, arc);
            insecurite_new =  insecurite_ref - insecurite_arc_resultat(data, nb_lieux, id_resultat, lieu) + insecurite_arc(data, id_depart, id_destination, arc);

            if((distance_ref < distance_new)&&(insecurite_ref < insecurite_new)){
                continue; //new est dominé
            }
            if((distance_ref > distance_new)&&(insecurite_ref > insecurite_new)){
                /*le chemin de referance, est dominé, on modifi sont arc pour ne pas garder un chemin dominé, sur tout celui de la generation*/
                change_arc_resultat(data, nb_lieux, id_resultat, lieu, id_depart, id_destination, arc);

                distance_ref = distance_totale_resultat(data, nb_lieux, id_resultat);
                insecurite_ref = insecurite_totale_resultat(data, nb_lieux, id_resultat);
            }
            else{
                cpy_resultat(data, nb_lieux, id_write_resultat, id_resultat); /* c'est un nouveau chemin valide*/
                change_arc_resultat(data, nb_lieux, id_write_resultat, lieu, id_depart, id_destination, arc);
                id_write_resultat++;
            }
        }


    }
    
    /*on vide la table de tous les resultat non utilisé*/
    all_resultats(data, nb_lieux, data->resultat.nb_resultats[nb_lieux -1][0] - data->resultat.nb_resultats[nb_lieux -1][1]);

}

\end{verbatim}

\textit{Implémentation en C de l'algortime de epure\_resultats}
Le fonctionnement de cet algorithme est semblable à epure\_map, il semble plus simple car la fonction suprime\_resultat comble immédiatement les trous créer dans le tableau par la suppression.
Cependant, il reste des erreurs de désallocation mémoire qui ne sont pas géré.
\begin{verbatim}

void epure_resultats(Donnee *data, int nb_lieux){
    int id_referance, id_test;
    int interet_referance, distance_referance, insecurite_referance;
    int interet_test, distance_test, insecurite_test;

    /* pour tous les resultats du tableau, meme si cete valeir change*/
    for(id_referance = 0; id_referance < nb_resultats_use_by_lieu(data, nb_lieux); ++id_referance){

        /*valeurs de la referance*/
        interet_referance = data->resultat.resultats[nb_lieux -1][id_referance]->carac.interet;
        distance_referance = data->resultat.resultats[nb_lieux -1][id_referance]->carac.distance;
        insecurite_referance = data->resultat.resultats[nb_lieux -1][id_referance]->carac.insecurite;

        /*pour de refance +1 a la fin du tableau*/
        for(id_test = id_referance +1; id_test < nb_resultats_use_by_lieu(data, nb_lieux); ++id_test){
            /*valeur du teste*/
            interet_test = data->resultat.resultats[nb_lieux -1][id_test]->carac.interet;
            distance_test = data->resultat.resultats[nb_lieux -1][id_test]->carac.distance;
            insecurite_test = data->resultat.resultats[nb_lieux -1][id_test]->carac.insecurite;

            /*si les caracteristique sont identique*/
            if((interet_referance == interet_test)&&(distance_referance == distance_test)&&(insecurite_referance == insecurite_test)){
                
                if(compar_resultats(data, nb_lieux, id_referance, id_test) == 0){// teste si les chemins sont idantiques
                    //suprimer test
                    suprime_resultat(data, nb_lieux, id_test);
                }
            }
            else {
                /*si il est dominé*/
                if((interet_referance >= interet_test)&&(distance_referance <= distance_test)&&(insecurite_referance <= insecurite_test)){
                    suprime_resultat(data, nb_lieux, id_test);
                }
                else {
                    /*si la referance est dominé*/
                    if((interet_referance <= interet_test)&&(distance_referance >= distance_test)&&(insecurite_referance >= insecurite_test)){
                        replace_resultat(data, nb_lieux, id_referance, id_test);
                        suprime_resultat(data, nb_lieux, id_test);

                        /*mise a jour des valeurs de la referance*/
                        interet_referance = interet_test;
                        distance_referance = distance_test;
                        insecurite_referance = insecurite_test;
                    }
                }
            }
        }
    }
}

\end{verbatim}

\textit{Voici l'implémentation de l'algorithme suprime\_resultat}
\begin{verbatim}

static void suprime_resultat(Donnee *data, int nb_lieux, int id_resultat){
    int i;
    //Parcourt **tmp_doubptr_parcourt;

    free(data->resultat.resultats[nb_lieux -1][id_resultat]->itineraire);
    free(data->resultat.resultats[nb_lieux -1][id_resultat]->trajet);
    if(data->resultat.resultats[nb_lieux -1][id_resultat]->visite != NULL){
        free(data->resultat.resultats[nb_lieux -1][id_resultat]->visite);
    }


    for(i = id_resultat; i < nb_resultats_use_by_lieu(data, nb_lieux) -1; ++i){
        data->resultat.resultats[nb_lieux -1][i] = data->resultat.resultats[nb_lieux -1][i +1];
    }

    data->resultat.resultats[nb_lieux -1][i] = NULL;

    /*free(data->resultat.resultats[nb_lieux -1][i]->itineraire);
    free(data->resultat.resultats[nb_lieux -1][i]->trajet);
    if(data->resultat.resultats[nb_lieux -1][i]->visite != NULL){
        free(data->resultat.resultats[nb_lieux -1][i]->visite);
    }

    tmp_doubptr_parcourt = (Parcourt **)realloc(data->resultat.resultats[nb_lieux -1], i*sizeof(Parcourt*));
    if(tmp_doubptr_parcourt == NULL) fatalerreur(data, "suprime_resultat :  echeque de la realocation de lv2");
    data->resultat.resultats[nb_lieux -1] = tmp_doubptr_parcourt;

    data->resultat.nb_resultats[nb_lieux -1][1] = i;
    data->resultat.nb_resultats[nb_lieux -1][0]--;
}

\end{verbatim}



\newpage
\chapter{Création de chemin}

\section{Création d'un chemin de base}

\section{Création de nouveau chemin}
Pour créer de nouveau chemin à partir du chemin de base, il y a deux méthodes qui sont la permutation et l'insertion.

\subsection{Permutation}
La permutation consiste à interchanger des lieux dans la solutions, pour cela il faut procéder de la manière suivant :
\begin{enumerate}
\item Récuperer le chemin de base dans un tableau vide pour pouvoir travailler dessus
\item Parcourt du tableau pour tester l'existence d'arcs entre les différents lieux
\item Si il existe un arc entre deux lieux on peu envisager de les permuter à condition qu'il existe un arc entre le lieux précédent le 1er lieu concerner par la permutation ainsi que le lieu successeur de deuxième lieu concerner par la permutation. 
\item Si les deux conditions sont remplis on réalise la permutation.
\end{enumerate}

\algsetup{indent=3em}
\begin{algorithm}
\caption{Permutation}
\label{Permutation}
\begin{algorithmic}[1]
\REQUIRE ~\\
\ENSURE ~\\
\STATE Cpy\_Solution(data,Id\_Solution\_base,Id\_Solution\_New);
 \FOR{$i$ {\textbf du} 1\ier{}lieu \textbf{au} dernier lieu}
  	\IF {$Permutation\_Possible(i+2,i+1) = 1$}
		\STATE $tmp \gets lieu[i+2];$
		\STATE $lieu[i+2] \gets lieu[i+1];$
		\STATE $lieu[i+1] \gets tmp;$
		\STATE Sortie de la boucle
	\ELSE
		\STATE Retourner("Il n'y a pas de permutation possible")
	\ENDIF
\ENDFOR
\STATE Retourner(Le nouveau chemin)
\end{algorithmic}
\end{algorithm}

		
\chapter{Conclusion}

Nous avons, durant ce projet, chercher à mettre en place un programme permettant de répondre au problème posé, c'est à dire permettant de calculer des parcours sur une ville.
Nous avons donc réaliser une structure de donnée permettant de récupérer la configuration de la ville, placer en paramètre avec un ensemble de méthodes pour exploiter ces données pour effectuer des traitement dessus comme des recherches ou des tris. On a aussi essaye de trouver une méthode pour calculer des chemins.
Les méthodes utilisées que nous avons mis en place n'est pas nécessairement la meilleur, et peut surment être optimisée en particulier la méthode de permutation, d'insertion ainsi que la gestion des résultats retourner.

On tiens à remercier M. Néron pour nous avoir proposé ce sujet qui a été très instructif car il nous a permis d'avoir une première approche de la réalisation d'un projet informatique.    



\annexes
\chapter{Fiche de suivi de projet\label{sec:fiche_suivi}}

\CR{17/01/2011}{1ére rencontre avec Emmanuel Néron pour prendre une explication approfondi du sujet ainsi que le premier objectif à réaliser qui est le choix d'une structure de donnée pour gérer les villes.}
\CR{20/02/2011  au 04/03/2011}{Réflexion sur les méthodes possible pour la structure de donnée à mettre en place, ainsi que les algorithmes à utiliser pour parcourir les différentes structures de données}
\CR{04/03/2011 au 29/03/2011}{Réalisation de la structure de données pour gérer la configuration de la ville, mise en place d'algorithme de tri pour les arcs.}
\CR{07/04/2011}{Finalisation de la structure de données, vérification des fonctions permettant d'interroger la structure de données pour les algorithmes permettant de créé les trajets, première réalisation d'un algorithme pour générer le trajet de référence.}
\CR{11/04/2011}{Réunion avec notre encadrant pour lui présenter la structure de données et l'esquisse de l'algorithme pour générer le trajets de référence.}
\CR{11/04/2011 au 05/05/2011}{Réalisation et implémentation de l'algorithme pour générer un chemin de base et résolution d'un problème par rapport au tri des arc entre les lieux.}
\CR{05/05/2011 au 01/06/2011}{Recherche d'une méthode pour effectuer des permutations ou des insertions sur un chemin}
\CR{0106/2011 au 12/06/2001}{Finalisation et amélioration des méthodes utilisées, rédaction et finalisation du rapport }



\end{document}

